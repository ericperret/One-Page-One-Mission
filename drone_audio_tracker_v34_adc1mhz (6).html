<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syst√®me Kh√©ops v3.4 - ADC 1MHz</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #0f1419;
            --bg-tertiary: #151c24;
            --accent-red: #ff3b3b;
            --accent-green: #00ff88;
            --accent-cyan: #00d4ff;
            --accent-yellow: #ffd700;
            --accent-orange: #ff8c00;
            --accent-pink: #ff00ff;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --border-color: rgba(0, 212, 255, 0.3);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        
        body {
            font-family: 'Courier New', Consolas, monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: auto 1fr;
            gap: 10px;
            padding: 10px;
            height: 100vh;
        }
        
        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
        }
        
        header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green), var(--accent-cyan));
        }
        
        .logo { display: flex; align-items: center; gap: 10px; }
        .logo-icon { width: 35px; height: 35px; }
        
        h1 {
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: 2px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .version-tag {
            font-size: 0.55rem;
            color: var(--accent-pink);
            background: rgba(255, 0, 255, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            border: 1px solid rgba(255, 0, 255, 0.3);
        }
        
        .header-stats {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .stat-box {
            text-align: center;
            padding: 4px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .stat-box .value {
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-pink);
        }
        
        .stat-box .label {
            font-size: 0.5rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }
        
        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent-green);
            border-radius: 12px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-dot {
            width: 6px; height: 6px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .slowmo-indicator {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 255, 0.9);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            letter-spacing: 2px;
            z-index: 9999;
            display: none;
            animation: slowmo-pulse 0.5s ease-in-out infinite;
        }
        
        @keyframes slowmo-pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.8; transform: translateX(-50%) scale(1.05); }
        }
        
        .main-area {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }
        
        .views-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 8px;
            flex: 1;
            min-height: 0;
        }
        
        .view-panel {
            position: relative;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .view-panel canvas, #map {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #mapContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #mapOverlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 500;
        }
        
        .view-label {
            position: absolute;
            top: 4px; left: 4px;
            background: rgba(10, 14, 20, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 0.55rem;
            font-weight: 600;
            color: var(--accent-cyan);
            z-index: 1000;
        }
        
        .camera-active .view-label {
            color: var(--accent-pink);
            border-color: var(--accent-pink);
            background: rgba(255, 0, 255, 0.2);
            animation: blink 0.5s ease-in-out infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .time-display {
            position: absolute;
            bottom: 4px; right: 4px;
            background: rgba(10, 14, 20, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 0.6rem;
            z-index: 1000;
        }
        
        .time-display span { color: var(--accent-cyan); font-weight: 600; }
        
        .controls-row {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .btn {
            flex: 1;
            padding: 7px 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-cyan);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 255, 136, 0.2));
            border-color: var(--accent-cyan);
        }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            padding-right: 4px;
            min-height: 0;
        }
        
        .sidebar::-webkit-scrollbar { width: 5px; }
        .sidebar::-webkit-scrollbar-track { background: var(--bg-primary); }
        .sidebar::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .panel.fire-control {
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
        }
        
        .panel-header {
            padding: 6px 8px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .panel.fire-control .panel-header {
            background: rgba(255, 0, 255, 0.1);
        }
        
        .panel-header h3 {
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            letter-spacing: 1px;
            color: var(--accent-cyan);
        }
        
        .panel.fire-control .panel-header h3 {
            color: var(--accent-pink);
        }
        
        .panel-icon {
            width: 12px; height: 12px;
            color: var(--accent-cyan);
        }
        
        .panel.fire-control .panel-icon {
            color: var(--accent-pink);
        }
        
        .panel-content { padding: 8px; }
        
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .data-item {
            background: var(--bg-tertiary);
            padding: 5px 6px;
            border-radius: 4px;
            border: 1px solid rgba(0, 212, 255, 0.08);
        }
        
        .data-item.full-width { grid-column: 1 / -1; }
        
        .data-label {
            font-size: 0.5rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 1px;
        }
        
        .data-value {
            font-size: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: baseline;
            gap: 2px;
        }
        
        .data-value .unit {
            font-size: 0.55rem;
            color: var(--text-secondary);
            font-weight: 400;
        }
        
        .real-value { color: var(--accent-red); }
        .estimated-value { color: var(--accent-green); }
        .error-value { color: var(--accent-yellow); }
        .fire-value { color: var(--accent-pink); }
        
        .fire-assessment {
            padding: 8px;
            border-radius: 5px;
            text-align: center;
        }
        
        .fire-go {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.1));
            border: 1px solid var(--accent-green);
        }
        
        .fire-no-go {
            background: linear-gradient(135deg, rgba(255, 59, 59, 0.2), rgba(200, 50, 50, 0.1));
            border: 1px solid var(--accent-red);
        }
        
        .fire-engaged {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3), rgba(200, 0, 200, 0.1));
            border: 2px solid var(--accent-pink);
            animation: fire-pulse 0.3s ease-in-out infinite;
        }
        
        @keyframes fire-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 255, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.8); }
        }
        
        .fire-status {
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 3px;
        }
        
        .fire-go .fire-status { color: var(--accent-green); }
        .fire-no-go .fire-status { color: var(--accent-red); }
        .fire-engaged .fire-status { color: var(--accent-pink); }
        
        .fire-details { font-size: 0.55rem; color: var(--text-secondary); }
        
        .slider-container { margin: 5px 0; }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.55rem;
            margin-bottom: 2px;
        }
        
        .slider-label span:first-child { color: var(--text-secondary); }
        .slider-label span:last-child { color: var(--accent-cyan); font-weight: 600; }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: var(--bg-tertiary);
            border-radius: 2px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px; height: 10px;
            background: var(--accent-cyan);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .handover-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 5px;
            margin-bottom: 8px;
        }
        
        .handover-box {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .handover-kheops {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid var(--accent-cyan);
            color: var(--accent-cyan);
        }
        
        .handover-kheops.active {
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }
        
        .handover-camera {
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid var(--accent-pink);
            color: var(--accent-pink);
        }
        
        .handover-camera.active {
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            animation: blink 0.5s ease-in-out infinite;
        }
        
        .handover-arrow {
            color: var(--text-secondary);
            font-size: 1.2rem;
        }
        
        .doppler-indicator {
            margin-top: 8px;
            padding: 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.55rem;
        }
        
        .doppler-bar {
            height: 6px;
            background: var(--bg-primary);
            border-radius: 3px;
            margin-top: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .doppler-fill {
            height: 100%;
            border-radius: 3px;
            transition: all 0.1s;
        }
        
        .doppler-deadzone {
            position: absolute;
            top: 0;
            left: 45%;
            width: 10%;
            height: 100%;
            background: rgba(255, 59, 59, 0.3);
            border-left: 1px solid var(--accent-red);
            border-right: 1px solid var(--accent-red);
        }
        
        /* Leaflet */
        .leaflet-container { background: var(--bg-primary) !important; }
        .leaflet-control-zoom { border: 1px solid var(--border-color) !important; border-radius: 4px !important; }
        .leaflet-control-zoom a {
            background: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            width: 24px !important; height: 24px !important;
            line-height: 24px !important; font-size: 12px !important;
        }
        .leaflet-control-attribution { display: none; }
    </style>
</head>
<body>
    <!-- Slowmo supprim√© -->
    
    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <svg viewBox="0 0 50 50" fill="none">
                        <polygon points="25,5 45,40 5,40" stroke="url(#grad)" stroke-width="2" fill="none"/>
                        <circle cx="25" cy="28" r="4" fill="#00d4ff"/>
                        <circle cx="15" cy="38" r="3" fill="#00ff88"/>
                        <circle cx="35" cy="38" r="3" fill="#00ff88"/>
                        <defs>
                            <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#00d4ff"/>
                                <stop offset="100%" style="stop-color:#00ff88"/>
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                <div>
                    <h1>KH√âOPS <span class="version-tag">v3.4 ADC1M</span></h1>
                    <div style="font-size: 0.5rem; color: var(--text-secondary);">
                        Propagation Acoustique - Bulle Dynamique
                    </div>
                </div>
            </div>
            
            <div class="header-stats">
                <div class="stat-box">
                    <div class="value" id="killCount">0</div>
                    <div class="label">Kills</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="totalShots">0</div>
                    <div class="label">Tirs</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="accuracy">--%</div>
                    <div class="label">Pr√©cision</div>
                </div>
            </div>
            
            <div class="status-badge">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">PR√äT</span>
            </div>
        </header>
        
        <div class="main-area">
            <div class="views-container">
                <div class="view-panel">
                    <div class="view-label">KH√âOPS - VUE DESSUS</div>
                    <div id="mapContainer">
                        <div id="map"></div>
                        <canvas id="mapOverlay"></canvas>
                    </div>
                </div>
                
                <div class="view-panel">
                    <div class="view-label">VUE LAT√âRALE</div>
                    <canvas id="canvasSide"></canvas>
                    <div class="time-display">T+ <span id="simTime">0.00</span>s</div>
                </div>
                
                <div class="view-panel" id="cameraPanel">
                    <div class="view-label">CAM√âRA TIR - STANDBY</div>
                    <canvas id="canvasCamera"></canvas>
                </div>
                
                <div class="view-panel" id="reticlePanel">
                    <div class="view-label">VISEUR - STANDBY</div>
                    <canvas id="canvasReticle"></canvas>
                </div>
            </div>
            
            <div class="controls-row">
                <button class="btn btn-primary" id="startBtn" onclick="toggleSimulation()">‚ñ∂ START</button>
                <button class="btn" onclick="resetSimulation()">‚ü≤ RESET</button>
                <button class="btn" onclick="resetStats()">üìä RESET STATS</button>
            </div>
        </div>
        
        <div class="sidebar">
            <!-- CONDUITE DE TIR -->
            <div class="panel fire-control">
                <div class="panel-header">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
                    </svg>
                    <h3>CONDUITE DE TIR</h3>
                </div>
                <div class="panel-content">
                    <div class="handover-indicator">
                        <div class="handover-box handover-kheops active" id="hoverKheops">KH√âOPS</div>
                        <div class="handover-arrow">‚Üí</div>
                        <div class="handover-box handover-camera" id="hoverCamera">CAM√âRA</div>
                    </div>
                    
                    <div id="fireAssessment" class="fire-assessment fire-no-go">
                        <div class="fire-status">STANDBY</div>
                        <div class="fire-details">En attente</div>
                    </div>
                </div>
            </div>
            
            <!-- CIBLE ESTIM√âE -->
            <div class="panel fire-control">
                <div class="panel-header">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/><path d="M12 2v4M12 18v4M2 12h4M18 12h4"/>
                    </svg>
                    <h3>CIBLE ESTIM√âE</h3>
                </div>
                <div class="panel-content">
                    <div class="data-grid">
                        <div class="data-item">
                            <div class="data-label">Latitude</div>
                            <div class="data-value fire-value"><span id="fireLat">--</span><span class="unit">¬∞N</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Longitude</div>
                            <div class="data-value fire-value"><span id="fireLon">--</span><span class="unit">¬∞E</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Altitude</div>
                            <div class="data-value fire-value"><span id="fireAlt">--</span><span class="unit">m</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Distance</div>
                            <div class="data-value fire-value"><span id="fireDist">--</span><span class="unit">m</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- DOPPLER STATUS -->
            <div class="panel">
                <div class="panel-header">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
                    </svg>
                    <h3>DOPPLER</h3>
                </div>
                <div class="panel-content">
                    <div class="data-grid">
                        <div class="data-item">
                            <div class="data-label">V. Radiale</div>
                            <div class="data-value" id="vRadialValue"><span>--</span><span class="unit">m/s</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Int√©gration</div>
                            <div class="data-value" id="integrationStatus"><span>--</span></div>
                        </div>
                        <div class="data-item full-width">
                            <div class="data-label">Vitesse du Son</div>
                            <div class="data-value" style="color: var(--accent-cyan);"><span id="soundSpeedDisplay">343.0</span><span class="unit">m/s</span></div>
                        </div>
                    </div>
                    <div class="doppler-indicator">
                        <div style="display: flex; justify-content: space-between;">
                            <span>√âloignement</span>
                            <span id="dopplerLabel">0 m/s</span>
                            <span>Approche</span>
                        </div>
                        <div class="doppler-bar">
                            <div class="doppler-deadzone"></div>
                            <div class="doppler-fill" id="dopplerFill"></div>
                        </div>
                        <div style="text-align: center; margin-top: 4px; color: var(--accent-red); font-size: 0.5rem;">
                            Zone morte ¬±2 m/s (pas d'int√©gration)
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- ISO 9613-1 DIAGNOSTICS -->
            <div class="panel" style="border-color: rgba(255, 215, 0, 0.4);">
                <div class="panel-header" style="background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent);">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="#ffd700" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/>
                    </svg>
                    <h3 style="color: #ffd700;">ISO 9613-1</h3>
                </div>
                <div class="panel-content">
                    <div class="data-grid" style="grid-template-columns: 1fr 1fr; gap: 4px;">
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">P<sub>sat</sub> (Magnus)</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoPsat">--</span><span class="unit">Pa</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">f (Enhancement)</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoEnhancement">--</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">x<sub>H‚ÇÇO</sub> (mol)</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoXw">--</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">x<sub>CO‚ÇÇ</sub> (mol)</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoXc">--</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">M<sub>mix</sub></div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoM">--</span><span class="unit">g/mol</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Œ≥ (Cp/Cv)</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="isoGamma">--</span></div>
                        </div>
                        <div class="data-item full-width" style="border-top: 1px solid rgba(255, 215, 0, 0.2); padding-top: 4px; margin-top: 2px;">
                            <div class="data-label" style="font-size: 0.45rem;">c<sub>ISO</sub> vs c<sub>Cramer</sub></div>
                            <div class="data-value" style="font-size: 0.65rem; color: var(--accent-green);"><span id="isoComparison">--</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- VENT (PERTURBATEUR) -->
            <div class="panel" style="border-color: rgba(0, 191, 255, 0.5);">
                <div class="panel-header" style="background: linear-gradient(90deg, rgba(0, 191, 255, 0.15), transparent);">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="#00bfff" stroke-width="2">
                        <path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/>
                    </svg>
                    <h3 style="color: #00bfff;">VENT</h3>
                    <label style="margin-left: auto; display: flex; align-items: center; gap: 4px; font-size: 0.5rem;">
                        <input type="checkbox" id="windEnabled" checked onchange="toggleWind(this.checked)">
                        <span>Actif</span>
                    </label>
                </div>
                <div class="panel-content">
                    <div class="data-grid" style="grid-template-columns: 1fr 1fr; gap: 4px;">
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Vitesse</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="windSpeed">--</span><span class="unit">km/h</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Direction</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="windDirection">--</span><span class="unit">¬∞</span></div>
                        </div>
                        <div class="data-item full-width">
                            <div class="data-label" style="font-size: 0.45rem;">Status</div>
                            <div class="data-value" id="windStatus" style="font-size: 0.65rem;">--</div>
                        </div>
                    </div>
                    <!-- Rose des vents mini -->
                    <div style="display: flex; align-items: center; justify-content: center; margin-top: 6px;">
                        <canvas id="windRose" width="60" height="60" style="border-radius: 50%; background: rgba(0,0,0,0.3);"></canvas>
                    </div>
                    <div class="slider-container" style="margin-top: 6px;">
                        <div class="slider-label">
                            <span>Vitesse Base</span>
                            <span id="windBaseDisplay">20 km/h</span>
                        </div>
                        <input type="range" min="10" max="70" step="5" value="20" oninput="updateWindBase(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Direction Base</span>
                            <span id="windDirDisplay">45¬∞</span>
                        </div>
                        <input type="range" min="0" max="360" step="15" value="45" oninput="updateWindDirection(this.value)">
                    </div>
                </div>
            </div>
            
            <!-- COH√âRENCE G√âOM√âTRIQUE -->
            <div class="panel" style="border-color: rgba(255, 140, 0, 0.5);">
                <div class="panel-header" style="background: linear-gradient(90deg, rgba(255, 140, 0, 0.15), transparent);">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="#ff8c00" stroke-width="2">
                        <polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"/><line x1="12" y1="22" x2="12" y2="15.5"/><polyline points="22 8.5 12 15.5 2 8.5"/>
                    </svg>
                    <h3 style="color: #ff8c00;">COH√âRENCE</h3>
                    <label style="margin-left: auto; display: flex; align-items: center; gap: 4px; font-size: 0.5rem;">
                        <input type="checkbox" id="coherenceEnabled" checked onchange="toggleCoherence(this.checked)">
                        <span>Filtrage</span>
                    </label>
                </div>
                <div class="panel-content">
                    <div class="data-grid" style="grid-template-columns: 1fr 1fr; gap: 4px;">
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Indice</div>
                            <div class="data-value" style="font-size: 0.8rem;"><span id="coherenceIndex">--</span><span class="unit">%</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Dispersion</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="coherenceDispersion">--</span><span class="unit">m</span></div>
                        </div>
                        <div class="data-item full-width">
                            <div class="data-label" style="font-size: 0.45rem;">Solutions Valides</div>
                            <div class="data-value" style="font-size: 0.65rem;"><span id="coherenceSolutions">--</span><span class="unit">/ 210</span></div>
                        </div>
                    </div>
                    <!-- Barre de coh√©rence -->
                    <div style="margin-top: 6px;">
                        <div style="height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden;">
                            <div id="coherenceBar" style="height: 100%; width: 100%; background: linear-gradient(90deg, #ff3b3b, #ffd700, #00ff88); transition: width 0.2s;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.45rem; color: var(--text-secondary); margin-top: 2px;">
                            <span>RAFALE</span>
                            <span>STABLE</span>
                        </div>
                    </div>
                    <!-- Alerte rafale -->
                    <div id="gustAlert" style="display: none; margin-top: 6px; padding: 4px 8px; background: rgba(255, 59, 59, 0.2); border: 1px solid var(--accent-red); border-radius: 4px; text-align: center;">
                        <span style="color: var(--accent-red); font-size: 0.6rem; font-weight: bold;">‚ö†Ô∏è RAFALE D√âTECT√âE</span>
                    </div>
                    <!-- Alerte Zone Z√©nithale -->
                    <div id="zenithAlert" style="display: none; margin-top: 6px; padding: 4px 8px; background: rgba(255, 215, 0, 0.2); border: 1px solid var(--accent-yellow); border-radius: 4px; text-align: center;">
                        <span style="color: var(--accent-yellow); font-size: 0.6rem; font-weight: bold;">üìç ZONE Z√âNITHALE - Correction active</span>
                    </div>
                </div>
            </div>
            
            <!-- ACOUSTIQUE -->
            <div class="panel" style="border-color: rgba(138, 43, 226, 0.5);">
                <div class="panel-header" style="background: linear-gradient(90deg, rgba(138, 43, 226, 0.15), transparent);">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="#8a2be2" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                    </svg>
                    <h3 style="color: #8a2be2;">ACOUSTIQUE</h3>
                </div>
                <div class="panel-content">
                    <div class="data-grid" style="grid-template-columns: 1fr 1fr; gap: 4px;">
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">SNR</div>
                            <div class="data-value" style="font-size: 0.8rem;"><span id="snrValue">--</span><span class="unit">dB</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Niveau Re√ßu</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="receivedLevel">--</span><span class="unit">dB</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Bruit Fond</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="backgroundNoise">35</span><span class="unit">dB</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label" style="font-size: 0.45rem;">Port√©e Max</div>
                            <div class="data-value" style="font-size: 0.7rem;"><span id="maxRange">--</span><span class="unit">m</span></div>
                        </div>
                    </div>
                    <!-- Barre SNR -->
                    <div style="margin-top: 6px;">
                        <div style="display: flex; justify-content: space-between; font-size: 0.4rem; color: var(--text-secondary); margin-bottom: 2px;">
                            <span>INAUDIBLE</span>
                            <span>CLAIR</span>
                        </div>
                        <div style="height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden; position: relative;">
                            <div style="position: absolute; left: 20%; width: 1px; height: 100%; background: var(--accent-red);"></div>
                            <div id="snrBar" style="height: 100%; width: 50%; background: linear-gradient(90deg, #8a2be2, #00ff88); transition: width 0.2s;"></div>
                        </div>
                    </div>
                    <!-- S√©lecteurs -->
                    <div class="slider-container" style="margin-top: 8px;">
                        <div class="slider-label">
                            <span>Type Drone</span>
                            <span id="droneTypeDisplay">Consumer</span>
                        </div>
                        <select id="droneTypeSelect" onchange="updateDroneType(this.value)" style="width: 100%; padding: 3px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.55rem;">
                            <option value="mini">Mini (250g) - 74 dB</option>
                            <option value="consumer" selected>Consumer (600g) - 79 dB</option>
                            <option value="prosumer">Prosumer (1.2kg) - 83 dB</option>
                            <option value="pro">Pro (3kg) - 87 dB</option>
                            <option value="heavy">Lourd (5kg) - 90 dB</option>
                            <option value="fpv">FPV Racing - 95 dB</option>
                        </select>
                    </div>
                    <div class="slider-container" style="margin-top: 4px;">
                        <div class="slider-label">
                            <span>Terrain</span>
                            <span id="terrainDisplay">Campagne</span>
                        </div>
                        <select id="terrainSelect" onchange="updateTerrain(this.value)" style="width: 100%; padding: 3px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.55rem;">
                            <option value="water">Eau / Lac - 25 dB</option>
                            <option value="forest">For√™t - 30 dB</option>
                            <option value="country" selected>Campagne - 35 dB</option>
                            <option value="suburban">P√©riurbain - 45 dB</option>
                            <option value="urban">Urbain - 55 dB</option>
                            <option value="industrial">Industriel - 60 dB</option>
                        </select>
                    </div>
                    <!-- Alerte Signal Perdu -->
                    <div id="signalLostAlert" style="display: none; margin-top: 6px; padding: 6px 8px; background: rgba(255, 59, 59, 0.25); border: 2px solid var(--accent-red); border-radius: 4px; text-align: center;">
                        <div style="color: var(--accent-red); font-size: 0.7rem; font-weight: bold;">üì° SIGNAL PERDU</div>
                        <div style="color: var(--accent-red); font-size: 0.5rem; margin-top: 2px;">Drone hors port√©e acoustique</div>
                    </div>
                </div>
            </div>
            
            <!-- ERREURS -->
            <div class="panel">
                <div class="panel-header">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/><path d="M12 8v4M12 16h.01"/>
                    </svg>
                    <h3>PR√âCISION</h3>
                </div>
                <div class="panel-content">
                    <div class="data-grid">
                        <div class="data-item">
                            <div class="data-label">Err. Pos 3D</div>
                            <div class="data-value error-value" style="color: var(--accent-orange);"><span id="posError3D">--</span><span class="unit">m</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Err. Distance</div>
                            <div class="data-value error-value"><span id="distanceError">--</span><span class="unit">m</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Err. %</div>
                            <div class="data-value error-value"><span id="distanceErrorPct">--</span><span class="unit">%</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Dist. R√©elle</div>
                            <div class="data-value real-value"><span id="realDistance">--</span><span class="unit">m</span></div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Dist. Estim√©e</div>
                            <div class="data-value estimated-value"><span id="estDistance">--</span><span class="unit">m</span></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- PARAM√àTRES -->
            <div class="panel">
                <div class="panel-header">
                    <svg class="panel-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"/><path d="M12 1v6M12 17v6"/>
                    </svg>
                    <h3>PARAM√àTRES</h3>
                </div>
                <div class="panel-content">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Seuil Handover</span>
                            <span id="handoverDisplay">35 m</span>
                        </div>
                        <input type="range" min="20" max="60" step="5" value="35" oninput="updateHandover(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Vitesse Drone</span>
                            <span id="speedDisplay">12 m/s</span>
                        </div>
                        <input type="range" min="3" max="25" step="1" value="12" oninput="updateSpeed(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Dispersion Chevrotine</span>
                            <span id="spreadDisplay">5 m</span>
                        </div>
                        <input type="range" min="2" max="10" step="0.5" value="5" oninput="updateSpread(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>D√©lai Respawn</span>
                            <span id="respawnDisplay">2.0 s</span>
                        </div>
                        <input type="range" min="0.5" max="5" step="0.5" value="2" oninput="updateRespawn(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Temp√©rature</span>
                            <span id="tempDisplay">20 ¬∞C</span>
                        </div>
                        <input type="range" min="-20" max="45" step="1" value="20" oninput="updateTemperature(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Humidit√©</span>
                            <span id="humidityDisplay">50 %</span>
                        </div>
                        <input type="range" min="0" max="100" step="5" value="50" oninput="updateHumidity(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Pression Atmo.</span>
                            <span id="pressureDisplay">1013.25 hPa</span>
                        </div>
                        <input type="range" min="950" max="1050" step="0.5" value="1013.25" oninput="updatePressure(this.value)">
                    </div>
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>CO‚ÇÇ</span>
                            <span id="co2Display">400 ppm</span>
                        </div>
                        <input type="range" min="300" max="1000" step="10" value="400" oninput="updateCO2(this.value)">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ============================================================
    // CONSTANTES
    // ============================================================
    const BUBBLE_RADIUS = 150.0;
    const TRACE_DURATION = 5.0;
    const BASE_DT = 0.02;
    const RX_LAT = 43.2142;
    const RX_LON = 5.3665;
    // ============================================================
    // CONSTANTES G√âOD√âSIQUES (WGS84)
    // ============================================================
    const WGS84_A = 6378137.0;           // Demi-grand axe (m)
    const WGS84_B = 6356752.314245;      // Demi-petit axe (m)
    const WGS84_E2 = 1 - (WGS84_B * WGS84_B) / (WGS84_A * WGS84_A); // Excentricit√©¬≤
    
    // Rayon de courbure m√©ridien (Nord-Sud) √† une latitude donn√©e
    function radiusMeridian(latRad) {
        const sinLat = Math.sin(latRad);
        return WGS84_A * (1 - WGS84_E2) / Math.pow(1 - WGS84_E2 * sinLat * sinLat, 1.5);
    }
    
    // Rayon de courbure premier vertical (Est-Ouest) √† une latitude donn√©e
    function radiusPrimeVertical(latRad) {
        const sinLat = Math.sin(latRad);
        return WGS84_A / Math.sqrt(1 - WGS84_E2 * sinLat * sinLat);
    }
    
    // M√®tres par degr√© de latitude √† une latitude donn√©e
    function metersPerDegLat(latDeg) {
        const latRad = latDeg * Math.PI / 180;
        return radiusMeridian(latRad) * Math.PI / 180;
    }
    
    // M√®tres par degr√© de longitude √† une latitude donn√©e
    function metersPerDegLon(latDeg) {
        const latRad = latDeg * Math.PI / 180;
        return radiusPrimeVertical(latRad) * Math.cos(latRad) * Math.PI / 180;
    }
    
    // Zone morte Doppler - PAS d'int√©gration si |v_radiale| < seuil
    const DOPPLER_DEADZONE = 2.0; // m/s
    
    // ============================================================
    // VITESSE DU SON - ISO 9613-1:1993 (COMPL√àTE)
    // ============================================================
    // R√©f√©rence: ISO 9613-1:1993 "Acoustics - Attenuation of sound 
    // during propagation outdoors - Part 1: Calculation of the 
    // absorption of sound by the atmosphere"
    // 
    // Impl√©mentation state of the art avec TOUS les param√®tres:
    // - Temp√©rature (¬∞C)
    // - Humidit√© relative (%)
    // - Pression atmosph√©rique (hPa)
    // - Fraction molaire de CO‚ÇÇ (xc)
    // ============================================================
    
    // Param√®tres atmosph√©riques
    let TEMPERATURE = 20.0;        // ¬∞C
    let HUMIDITY = 50.0;           // % HR
    let PRESSURE = 1013.25;        // hPa (pression atmosph√©rique)
    let CO2_FRACTION = 0.0004;     // Fraction molaire CO‚ÇÇ (400 ppm standard)
    
    // Constantes physiques fondamentales
    const R_UNIVERSAL = 8.31446261815324;  // J/(mol¬∑K) - Constante des gaz parfaits
    const M_DRY_AIR = 0.0289652;           // kg/mol - Masse molaire air sec
    const M_WATER = 0.01801528;            // kg/mol - Masse molaire eau
    const M_CO2 = 0.04401;                 // kg/mol - Masse molaire CO‚ÇÇ
    
    // Constantes thermodynamiques
    const GAMMA_DRY = 1.4;                 // Rapport Cp/Cv air sec (diatomique)
    const GAMMA_WATER = 1.33;              // Rapport Cp/Cv vapeur d'eau
    const GAMMA_CO2 = 1.30;                // Rapport Cp/Cv CO‚ÇÇ
    
    // Temp√©ratures de r√©f√©rence
    const T_REF = 293.15;                  // K (20¬∞C)
    const T_TRIPLE = 273.16;               // K (point triple de l'eau)
    const T_01 = 273.15;                   // K (0¬∞C)
    
    // Pression de r√©f√©rence
    const P_REF = 101325;                  // Pa
    const P_TRIPLE = 611.657;              // Pa (pression au point triple)
    
    /**
     * Calcul de la pression de vapeur saturante selon ISO 9613-1
     * Utilise l'√©quation de Magnus-Tetens am√©lior√©e (formule de Sonntag 1990)
     * Pr√©cision: ¬±0.01% pour -45¬∞C √† +60¬∞C
     * 
     * @param {number} T - Temp√©rature en Kelvin
     * @returns {number} Pression de vapeur saturante en Pa
     */
    function saturationVaporPressure_ISO(T) {
        // Formule de Sonntag (1990) - recommand√©e par WMO
        // ln(psat) = -6096.9385/T + 16.635794 - 2.711193e-2*T 
        //            + 1.673952e-5*T¬≤ + 2.433502*ln(T)
        const lnPsat = -6096.9385 / T 
                     + 16.635794 
                     - 2.711193e-2 * T 
                     + 1.673952e-5 * T * T 
                     + 2.433502 * Math.log(T);
        return Math.exp(lnPsat);
    }
    
    /**
     * Formule alternative de Hyland-Wexler (ASHRAE RP-216)
     * Utilis√©e par certains laboratoires de m√©trologie
     * Pr√©cision: ¬±0.005% pour 0¬∞C √† +100¬∞C
     * 
     * @param {number} T - Temp√©rature en Kelvin
     * @returns {number} Pression de vapeur saturante en Pa
     */
    function saturationVaporPressure_HylandWexler(T) {
        // Coefficients Hyland-Wexler pour l'eau liquide (T > 273.15 K)
        const C1 = -5.8002206e3;
        const C2 = 1.3914993e0;
        const C3 = -4.8640239e-2;
        const C4 = 4.1764768e-5;
        const C5 = -1.4452093e-8;
        const C6 = 6.5459673e0;
        
        const lnPsat = C1/T + C2 + C3*T + C4*T*T + C5*T*T*T + C6*Math.log(T);
        return Math.exp(lnPsat);
    }
    
    /**
     * Facteur d'augmentation (enhancement factor) selon ISO 9613-1
     * Corrige l'√©cart √† l'id√©alit√© du m√©lange air-vapeur d'eau
     * 
     * @param {number} T - Temp√©rature en Kelvin
     * @param {number} p - Pression totale en Pa
     * @returns {number} Facteur d'augmentation (sans dimension, ~1.004)
     */
    function enhancementFactor(T, p) {
        // Formule de Greenspan (1976) simplifi√©e pour ISO 9613-1
        // f = 1 + Œ±*p + Œ≤*p¬≤ o√π Œ± et Œ≤ d√©pendent de T
        const alpha = 3.14e-8;   // Pa‚Åª¬π
        const beta = 5.6e-7;     // Pa‚Åª¬π (terme temp√©rature)
        const tC = T - T_01;
        
        // Facteur d'augmentation avec correction temp√©rature
        const f = 1.00062 + 3.14e-8 * p + 5.6e-7 * tC * tC;
        return f;
    }
    
    /**
     * Calcul de la fraction molaire de vapeur d'eau
     * 
     * @param {number} hr - Humidit√© relative (0-100)
     * @param {number} T - Temp√©rature en Kelvin
     * @param {number} p - Pression totale en Pa
     * @returns {number} Fraction molaire de vapeur d'eau
     */
    function molarFractionWater(hr, T, p) {
        const psat = saturationVaporPressure_ISO(T);
        const f = enhancementFactor(T, p);
        const h = (hr / 100) * f * psat / p;
        return h;
    }
    
    /**
     * Calcul de la masse molaire du m√©lange air humide avec CO‚ÇÇ
     * 
     * @param {number} xw - Fraction molaire vapeur d'eau
     * @param {number} xc - Fraction molaire CO‚ÇÇ
     * @returns {number} Masse molaire en kg/mol
     */
    function molarMassMixture(xw, xc) {
        // Air sec sans CO‚ÇÇ = N‚ÇÇ (78.08%) + O‚ÇÇ (20.95%) + Ar (0.93%)
        // Masse molaire air sec standard = 28.9652 g/mol
        const xDryAir = 1 - xw - xc;
        const M = xDryAir * M_DRY_AIR + xw * M_WATER + xc * M_CO2;
        return M;
    }
    
    /**
     * Calcul du rapport des chaleurs sp√©cifiques Œ≥ = Cp/Cv
     * pour le m√©lange gazeux (air + vapeur + CO‚ÇÇ)
     * 
     * @param {number} xw - Fraction molaire vapeur d'eau
     * @param {number} xc - Fraction molaire CO‚ÇÇ
     * @returns {number} Rapport Œ≥ du m√©lange
     */
    function heatCapacityRatio(xw, xc) {
        // Moyenne pond√©r√©e par les fractions molaires
        // Cp = Œ£(xi * Cp,i) et Cv = Œ£(xi * Cv,i)
        // Pour gaz parfaits: Œ≥ ‚âà Œ£(xi * Œ≥i * Cv,i) / Œ£(xi * Cv,i)
        
        // Capacit√©s calorifiques molaires √† volume constant (J/(mol¬∑K))
        // Cv = R/(Œ≥-1) pour gaz parfait
        const Cv_dry = R_UNIVERSAL / (GAMMA_DRY - 1);      // Air sec: 20.79
        const Cv_water = R_UNIVERSAL / (GAMMA_WATER - 1);  // Vapeur: 25.19
        const Cv_co2 = R_UNIVERSAL / (GAMMA_CO2 - 1);      // CO‚ÇÇ: 27.71
        
        const xDry = 1 - xw - xc;
        
        // Cv du m√©lange
        const Cv_mix = xDry * Cv_dry + xw * Cv_water + xc * Cv_co2;
        
        // Cp du m√©lange (Cp = Cv + R pour gaz parfait)
        const Cp_mix = Cv_mix + R_UNIVERSAL;
        
        return Cp_mix / Cv_mix;
    }
    
    /**
     * FONCTION PRINCIPALE: Vitesse du son selon ISO 9613-1
     * 
     * Formule fondamentale: c = ‚àö(Œ≥¬∑R¬∑T/M)
     * 
     * o√π:
     * - Œ≥ = rapport des chaleurs sp√©cifiques du m√©lange
     * - R = constante universelle des gaz parfaits
     * - T = temp√©rature absolue (K)
     * - M = masse molaire du m√©lange (kg/mol)
     * 
     * @param {number} tempC - Temp√©rature en ¬∞C
     * @param {number} humidityPct - Humidit√© relative en %
     * @param {number} pressureHPa - Pression atmosph√©rique en hPa
     * @param {number} xCO2 - Fraction molaire de CO‚ÇÇ (d√©faut 0.0004 = 400 ppm)
     * @returns {number} Vitesse du son en m/s
     */
    function calculateSpeedOfSound_ISO9613(tempC, humidityPct, pressureHPa, xCO2 = 0.0004) {
        const T = tempC + T_01;           // Conversion en Kelvin
        const p = pressureHPa * 100;      // Conversion en Pa
        
        // Fraction molaire de vapeur d'eau
        const xw = molarFractionWater(humidityPct, T, p);
        
        // Masse molaire du m√©lange
        const M = molarMassMixture(xw, xCO2);
        
        // Rapport des chaleurs sp√©cifiques
        const gamma = heatCapacityRatio(xw, xCO2);
        
        // Vitesse du son: c = ‚àö(Œ≥¬∑R¬∑T/M)
        const c = Math.sqrt(gamma * R_UNIVERSAL * T / M);
        
        return c;
    }
    
    /**
     * Formule simplifi√©e de Cramer (1993) pour comparaison
     * Pr√©cision: ~0.1% (r√©f√©rence ISO)
     */
    function calculateSpeedOfSound_Cramer(tempC, humidityPct, pressureHPa, xCO2 = 0.0004) {
        const T = tempC + T_01;
        const p = pressureHPa * 100;
        const t = tempC;  // pour lisibilit√©
        
        // Fraction molaire vapeur d'eau
        const xw = molarFractionWater(humidityPct, T, p);
        
        // Formule polynomiale de Cramer (J. Acoust. Soc. Am. 93, 1993)
        // c = a0 + a1*t + a2*t¬≤ + (a3 + a4*t + a5*t¬≤)*xw 
        //     + (a6 + a7*t + a8*t¬≤)*p + (a9 + a10*t + a11*t¬≤)*xc
        //     + a12*xw¬≤ + a13*p¬≤ + a14*xc¬≤ + a15*xw*p*xc
        
        const a0 = 331.5024;
        const a1 = 0.603055;
        const a2 = -0.000528;
        const a3 = 51.471935;
        const a4 = 0.1495874;
        const a5 = -0.000782;
        const a6 = -1.82e-7;
        const a7 = 3.73e-8;
        const a8 = -2.93e-10;
        const a9 = -85.20931;
        const a10 = -0.228525;
        const a11 = 5.91e-5;
        const a12 = -2.835149;
        const a13 = -2.15e-13;
        const a14 = 29.179762;
        const a15 = 0.000486;
        
        const c = a0 + a1*t + a2*t*t 
                + (a3 + a4*t + a5*t*t) * xw
                + (a6 + a7*t + a8*t*t) * p
                + (a9 + a10*t + a11*t*t) * xCO2
                + a12 * xw * xw
                + a13 * p * p
                + a14 * xCO2 * xCO2
                + a15 * xw * p * xCO2;
        
        return c;
    }
    
    /**
     * Fonction wrapper qui utilise ISO 9613-1 par d√©faut
     */
    function calculateSpeedOfSound(tempC, humidityPct) {
        return calculateSpeedOfSound_ISO9613(tempC, humidityPct, PRESSURE, CO2_FRACTION);
    }
    
    /**
     * Calcul d√©taill√© avec retour de tous les param√®tres interm√©diaires
     * (pour affichage diagnostic)
     */
    function calculateSpeedOfSoundDetailed(tempC, humidityPct, pressureHPa, xCO2) {
        const T = tempC + T_01;
        const p = pressureHPa * 100;
        
        const psat = saturationVaporPressure_ISO(T);
        const f = enhancementFactor(T, p);
        const xw = molarFractionWater(humidityPct, T, p);
        const M = molarMassMixture(xw, xCO2);
        const gamma = heatCapacityRatio(xw, xCO2);
        const c = Math.sqrt(gamma * R_UNIVERSAL * T / M);
        
        // Calcul aussi avec Cramer pour comparaison
        const c_cramer = calculateSpeedOfSound_Cramer(tempC, humidityPct, pressureHPa, xCO2);
        
        return {
            temperature_K: T,
            pressure_Pa: p,
            saturationPressure_Pa: psat,
            enhancementFactor: f,
            molarFractionH2O: xw,
            molarFractionCO2: xCO2,
            molarMass_kgmol: M,
            gammaRatio: gamma,
            speedOfSound_ISO: c,
            speedOfSound_Cramer: c_cramer,
            deviation_ms: Math.abs(c - c_cramer),
            deviation_pct: Math.abs(c - c_cramer) / c * 100
        };
    }
    
    let SPEED_OF_SOUND = calculateSpeedOfSound(TEMPERATURE, HUMIDITY);
    let HANDOVER_DISTANCE = 35.0;
    let SHOTGUN_SPREAD = 5.0;
    let RESPAWN_DELAY = 2.0;
    
    // ============================================================
    // CONSTANTES DE S√âCURIT√â NUM√âRIQUE
    // ============================================================
    const EPSILON = 1e-10;          // Protection division par z√©ro
    const EPSILON_VELOCITY = 0.001; // Seuil vitesse minimale (m/s)
    const EPSILON_DISTANCE = 0.01;  // Seuil distance minimale (m)
    const MAX_DRONE_SPEED = 30;     // Vitesse max physique drone (m/s)
    const MAX_ALTITUDE = 500;       // Altitude max r√©aliste (m)
    const MIN_ALTITUDE = 0.5;       // Altitude min (m)
    
    // ============================================================
    // SIMULATEUR SIGNAL ADC 1 MHz - WAVETABLE
    // ============================================================
    // Pr√©calcul d'une p√©riode dans un tableau
    // Lecture par index pour √©viter les calculs temps r√©el
    // ============================================================
    
    const ADC = {
        sampleRate: 1000000,       // 1 MHz
        bitsResolution: 16,        // 16 bits (0-65535)
        windowSize: 5000,          // 5 ms de fen√™tre
        channels: 5,
        
        // Buffers circulaires [channel][sample]
        buffers: null,
        writeIndex: 0,
        samplesTotal: 0,
        
        // Config signal drone
        numBlades: 4,
        rpm: 10000,
        harmonics: 5,
        
        // WAVETABLE pr√©calcul√©e
        wavetable: null,
        wavetableSize: 0,
        
        // Limite de samples par frame pour √©viter saturation
        maxSamplesPerFrame: 2000,
        
        // R√©sultats
        tdoaReady: false,
        lastTDOA: null,
        lastTOA: null,
        
        // Compteur pour rafra√Æchir TDOA p√©riodiquement
        correlationCounter: 0,
        correlationInterval: 10  // Toutes les N frames
    };
    
    /**
     * G√©n√©rer la wavetable (une p√©riode du signal)
     */
    function generateWavetable() {
        const f0 = ADC.numBlades * ADC.rpm / 60; // Fr√©quence fondamentale
        const period = 1.0 / f0;                  // Dur√©e d'une p√©riode
        const numSamples = Math.round(period * ADC.sampleRate);
        
        ADC.wavetable = new Float32Array(numSamples);
        ADC.wavetableSize = numSamples;
        
        // Pr√©calculer une p√©riode avec harmoniques
        for (let i = 0; i < numSamples; i++) {
            const t = i / ADC.sampleRate;
            let signal = 0;
            for (let h = 1; h <= ADC.harmonics; h++) {
                signal += Math.sin(2 * Math.PI * h * f0 * t) / h;
            }
            ADC.wavetable[i] = signal / 2; // Normaliser [-0.5, +0.5]
        }
        
        console.log(`Wavetable: ${numSamples} samples, f0=${f0.toFixed(1)} Hz`);
    }
    
    /**
     * Lire la wavetable √† un instant t (interpolation lin√©aire)
     */
    function readWavetable(t) {
        if (!ADC.wavetable || ADC.wavetableSize === 0) return 0;
        
        const f0 = ADC.numBlades * ADC.rpm / 60;
        const period = 1.0 / f0;
        
        // Position dans la p√©riode [0, 1)
        const phase = (t % period) / period;
        if (phase < 0) return 0;
        
        // Index flottant dans la wavetable
        const idx = phase * ADC.wavetableSize;
        const i0 = Math.floor(idx) % ADC.wavetableSize;
        const i1 = (i0 + 1) % ADC.wavetableSize;
        const frac = idx - Math.floor(idx);
        
        // Interpolation lin√©aire
        return ADC.wavetable[i0] * (1 - frac) + ADC.wavetable[i1] * frac;
    }
    
    /**
     * Initialiser les buffers ADC
     */
    function initADC() {
        ADC.buffers = [];
        for (let ch = 0; ch < ADC.channels; ch++) {
            // 16 bits sign√© (-32768 √† +32767) pour la corr√©lation
            ADC.buffers[ch] = new Int16Array(ADC.windowSize);
        }
        ADC.writeIndex = 0;
        ADC.samplesTotal = 0;
        ADC.tdoaReady = false;
        ADC.correlationCounter = 0;
        
        // G√©n√©rer la wavetable
        generateWavetable();
        
        console.log('ADC initialized: 1MHz √ó 5ch √ó 16bit');
    }
    
    /**
     * Simuler l'acquisition ADC pour un pas de temps
     */
    function simulateADC(dronePos, dt) {
        // Limiter le nombre de samples par frame
        let numSamples = Math.round(dt * ADC.sampleRate);
        numSamples = Math.min(numSamples, ADC.maxSamplesPerFrame);
        
        if (numSamples <= 0) return;
        
        // D√©lais de propagation (avec vent) - calcul√©s une fois par frame
        const delays = SENSORS.map(s => propagationTimeWithWind(dronePos, s));
        
        // Att√©nuations (1/r) - calcul√©es une fois par frame
        const attenuations = SENSORS.map(s => {
            const d = Math.sqrt(
                (dronePos.x - s.x)**2 + (dronePos.y - s.y)**2 + (dronePos.z - s.z)**2
            );
            return Math.min(1, 20 / Math.max(d, 1));
        });
        
        // Temps de base
        const t0 = ADC.samplesTotal / ADC.sampleRate;
        const dtSample = 1.0 / ADC.sampleRate;
        
        // Amplitude max 16 bits (sign√©: -32768 √† +32767)
        const maxAmplitude = 32000; // L√©g√®re marge pour √©viter clipping
        
        // G√©n√©rer √©chantillons via wavetable
        for (let i = 0; i < numSamples; i++) {
            const t = t0 + i * dtSample;
            const idx = (ADC.writeIndex + i) % ADC.windowSize;
            
            for (let ch = 0; ch < ADC.channels; ch++) {
                const tDelayed = t - delays[ch];
                let sample = 0;
                if (tDelayed > 0) {
                    // Wavetable retourne [-0.5, +0.5], on scale en 16 bits
                    sample = readWavetable(tDelayed) * attenuations[ch] * maxAmplitude;
                }
                // Stocker en Int16
                ADC.buffers[ch][idx] = Math.round(sample);
            }
        }
        
        ADC.writeIndex = (ADC.writeIndex + numSamples) % ADC.windowSize;
        ADC.samplesTotal += numSamples;
        
        // Buffer plein ?
        ADC.tdoaReady = ADC.samplesTotal >= ADC.windowSize;
    }
    
    /**
     * Extraire les TDOA par corr√©lation crois√©e
     * TDOA entre capteurs espac√©s de ~1-2m ‚Üí max ~6ms ‚Üí 6000 samples
     * Buffers en Int16 (-32768 √† +32767)
     */
    function extractTDOA_Correlation() {
        if (!ADC.tdoaReady) return null;
        
        const N = ADC.windowSize; // 5000
        const maxLag = Math.min(2000, Math.floor(N / 2) - 10); // ¬±2ms max
        const step = 8;     // Recherche grossi√®re
        
        // R√©f√©rence directe aux buffers Int16 (pas de copie)
        const buffers = ADC.buffers;
        
        const tdoas = [];
        
        // Corr√©lation pour chaque paire (r√©f√©rence = capteur 0)
        for (let j = 1; j < ADC.channels; j++) {
            const a = buffers[0]; // R√©f√©rence (Int16Array)
            const b = buffers[j]; // Autre capteur (Int16Array)
            
            // Phase 1: Recherche grossi√®re
            let bestLag = 0;
            let bestCorr = -Infinity;
            
            for (let lag = -maxLag; lag <= maxLag; lag += step) {
                let corr = 0;
                let count = 0;
                for (let k = 0; k < N; k++) {
                    const bk = k + lag;
                    if (bk >= 0 && bk < N) {
                        corr += a[k] * b[bk];
                        count++;
                    }
                }
                if (count > 0 && corr > bestCorr) {
                    bestCorr = corr;
                    bestLag = lag;
                }
            }
            
            // Phase 2: Recherche fine
            for (let lag = bestLag - step; lag <= bestLag + step; lag++) {
                if (lag < -maxLag || lag > maxLag) continue;
                let corr = 0;
                let count = 0;
                for (let k = 0; k < N; k++) {
                    const bk = k + lag;
                    if (bk >= 0 && bk < N) {
                        corr += a[k] * b[bk];
                        count++;
                    }
                }
                if (count > 0 && corr > bestCorr) {
                    bestCorr = corr;
                    bestLag = lag;
                }
            }
            
            // Interpolation parabolique sub-sample
            if (Math.abs(bestLag) < maxLag - 1) {
                let cm = 0, cp = 0;
                for (let k = 0; k < N; k++) {
                    const bkm = k + bestLag - 1;
                    const bkp = k + bestLag + 1;
                    if (bkm >= 0 && bkm < N) cm += a[k] * b[bkm];
                    if (bkp >= 0 && bkp < N) cp += a[k] * b[bkp];
                }
                const denom = 2 * (2 * bestCorr - cm - cp);
                if (Math.abs(denom) > EPSILON) {
                    bestLag += (cm - cp) / denom;
                }
            }
            
            // TDOA = lag en secondes (positif = j re√ßoit apr√®s 0)
            const tdoaValue = bestLag / ADC.sampleRate;
            
            tdoas.push({
                i: 0,
                j: j,
                value: tdoaValue,
                peak: bestCorr
            });
        }
        
        // Ajouter les autres paires par d√©duction
        // TDOA(i,j) = TDOA(0,j) - TDOA(0,i)
        for (let i = 1; i < ADC.channels; i++) {
            for (let j = i + 1; j < ADC.channels; j++) {
                const tdoa_0i = tdoas.find(t => t.j === i).value;
                const tdoa_0j = tdoas.find(t => t.j === j).value;
                tdoas.push({
                    i: i,
                    j: j,
                    value: tdoa_0j - tdoa_0i,
                    peak: 0 // D√©duit, pas mesur√©
                });
            }
        }
        
        ADC.lastTDOA = tdoas;
        return tdoas;
    }
    
    // ============================================================
    // FILTRE DE KALMAN 3D - Fusion Position/Vitesse
    // ============================================================
    // √âtat: [x, y, z, vx, vy, vz] (position + vitesse)
    // Observation: [x, y, z] (position acoustique)
    // ============================================================
    
    const KALMAN = {
        enabled: true,
        
        // √âtat estim√© [x, y, z, vx, vy, vz]
        state: [80, 0, 40, 0, 0, 0],
        
        // Matrice de covariance d'√©tat (6x6)
        P: null,
        
        // Param√®tres de bruit
        processNoise: 2.0,      // Bruit de processus (acc√©l√©ration impr√©vue) m/s¬≤
        measurementNoise: 5.0,  // Bruit de mesure acoustique (m)
        
        // Historique pour debug
        innovation: [0, 0, 0],  // Diff√©rence mesure - pr√©diction
        
        // Initialisation
        initialized: false
    };
    
    /**
     * Initialiser le filtre de Kalman
     */
    function kalmanInit() {
        // √âtat initial
        KALMAN.state = [80, 0, 40, 0, 0, 0];
        
        // Covariance initiale (grande incertitude)
        KALMAN.P = [
            [100, 0, 0, 0, 0, 0],
            [0, 100, 0, 0, 0, 0],
            [0, 0, 100, 0, 0, 0],
            [0, 0, 0, 25, 0, 0],
            [0, 0, 0, 0, 25, 0],
            [0, 0, 0, 0, 0, 25]
        ];
        
        KALMAN.initialized = true;
    }
    
    /**
     * Pr√©diction Kalman (mod√®le de mouvement)
     * @param {number} dt - Pas de temps en secondes
     */
    function kalmanPredict(dt) {
        if (!KALMAN.initialized) kalmanInit();
        
        const s = KALMAN.state;
        const q = KALMAN.processNoise;
        
        // Pr√©diction de l'√©tat: x_k = F * x_{k-1}
        // Mod√®le √† vitesse constante: pos += vel * dt
        const predictedState = [
            s[0] + s[3] * dt,  // x += vx * dt
            s[1] + s[4] * dt,  // y += vy * dt
            s[2] + s[5] * dt,  // z += vz * dt
            s[3],              // vx (constant)
            s[4],              // vy (constant)
            s[5]               // vz (constant)
        ];
        
        // Matrice de transition F (6x6)
        // [1 0 0 dt 0  0 ]
        // [0 1 0 0  dt 0 ]
        // [0 0 1 0  0  dt]
        // [0 0 0 1  0  0 ]
        // [0 0 0 0  1  0 ]
        // [0 0 0 0  0  1 ]
        
        // Pr√©diction de la covariance: P_k = F * P_{k-1} * F^T + Q
        const P = KALMAN.P;
        const dt2 = dt * dt;
        const dt3 = dt2 * dt / 2;
        const dt4 = dt2 * dt2 / 4;
        
        // Q: bruit de processus (acc√©l√©ration al√©atoire)
        const qdt4 = q * q * dt4;
        const qdt3 = q * q * dt3;
        const qdt2 = q * q * dt2;
        
        // Mise √† jour simplifi√©e de P (formule exacte pour mod√®le vitesse constante)
        const newP = [
            [P[0][0] + 2*dt*P[0][3] + dt2*P[3][3] + qdt4, P[0][1] + dt*(P[0][4]+P[3][1]) + dt2*P[3][4], P[0][2] + dt*(P[0][5]+P[3][2]) + dt2*P[3][5], P[0][3] + dt*P[3][3] + qdt3, P[0][4] + dt*P[3][4], P[0][5] + dt*P[3][5]],
            [P[1][0] + dt*(P[1][3]+P[4][0]) + dt2*P[4][3], P[1][1] + 2*dt*P[1][4] + dt2*P[4][4] + qdt4, P[1][2] + dt*(P[1][5]+P[4][2]) + dt2*P[4][5], P[1][3] + dt*P[4][3], P[1][4] + dt*P[4][4] + qdt3, P[1][5] + dt*P[4][5]],
            [P[2][0] + dt*(P[2][3]+P[5][0]) + dt2*P[5][3], P[2][1] + dt*(P[2][4]+P[5][1]) + dt2*P[5][4], P[2][2] + 2*dt*P[2][5] + dt2*P[5][5] + qdt4, P[2][3] + dt*P[5][3], P[2][4] + dt*P[5][4], P[2][5] + dt*P[5][5] + qdt3],
            [P[3][0] + dt*P[3][3] + qdt3, P[3][1] + dt*P[3][4], P[3][2] + dt*P[3][5], P[3][3] + qdt2, P[3][4], P[3][5]],
            [P[4][0] + dt*P[4][3], P[4][1] + dt*P[4][4] + qdt3, P[4][2] + dt*P[4][5], P[4][3], P[4][4] + qdt2, P[4][5]],
            [P[5][0] + dt*P[5][3], P[5][1] + dt*P[5][4], P[5][2] + dt*P[5][5] + qdt3, P[5][3], P[5][4], P[5][5] + qdt2]
        ];
        
        KALMAN.state = predictedState;
        KALMAN.P = newP;
    }
    
    /**
     * Mise √† jour Kalman (correction par mesure)
     * @param {object} measurement - Position mesur√©e {x, y, z}
     * @param {number} measurementNoise - Bruit de mesure (optionnel, sinon d√©faut)
     */
    function kalmanUpdate(measurement, measurementNoise = null) {
        if (!KALMAN.initialized) kalmanInit();
        
        const s = KALMAN.state;
        const P = KALMAN.P;
        const R = measurementNoise || KALMAN.measurementNoise;
        const R2 = R * R;
        
        // Innovation (r√©sidu): y = z - H * x
        // H = [1 0 0 0 0 0; 0 1 0 0 0 0; 0 0 1 0 0 0] (on observe x, y, z)
        const innovation = [
            measurement.x - s[0],
            measurement.y - s[1],
            measurement.z - s[2]
        ];
        KALMAN.innovation = innovation;
        
        // Covariance de l'innovation: S = H * P * H^T + R
        // S est 3x3, partie sup√©rieure gauche de P + R*I
        const S = [
            [P[0][0] + R2, P[0][1], P[0][2]],
            [P[1][0], P[1][1] + R2, P[1][2]],
            [P[2][0], P[2][1], P[2][2] + R2]
        ];
        
        // Inverser S (3x3)
        const Sinv = invert3x3(S);
        if (!Sinv) {
            console.warn('Kalman: matrice S singuli√®re');
            return;
        }
        
        // Gain de Kalman: K = P * H^T * S^-1
        // K est 6x3
        const K = [];
        for (let i = 0; i < 6; i++) {
            K[i] = [
                P[i][0] * Sinv[0][0] + P[i][1] * Sinv[1][0] + P[i][2] * Sinv[2][0],
                P[i][0] * Sinv[0][1] + P[i][1] * Sinv[1][1] + P[i][2] * Sinv[2][1],
                P[i][0] * Sinv[0][2] + P[i][1] * Sinv[1][2] + P[i][2] * Sinv[2][2]
            ];
        }
        
        // Mise √† jour de l'√©tat: x = x + K * y
        const newState = [];
        for (let i = 0; i < 6; i++) {
            newState[i] = s[i] + K[i][0] * innovation[0] + K[i][1] * innovation[1] + K[i][2] * innovation[2];
        }
        
        // Mise √† jour de la covariance: P = (I - K*H) * P
        const newP = [];
        for (let i = 0; i < 6; i++) {
            newP[i] = [];
            for (let j = 0; j < 6; j++) {
                let kh = 0;
                if (j < 3) kh = K[i][j]; // K*H simplifi√© car H = [I3 | 0]
                newP[i][j] = P[i][j] - (j < 3 ? K[i][0]*P[0][j] + K[i][1]*P[1][j] + K[i][2]*P[2][j] : 0);
            }
        }
        
        // Forcer sym√©trie et positivit√©
        for (let i = 0; i < 6; i++) {
            for (let j = i+1; j < 6; j++) {
                newP[i][j] = newP[j][i] = (newP[i][j] + newP[j][i]) / 2;
            }
            newP[i][i] = Math.max(newP[i][i], 0.01); // √âviter covariance nulle
        }
        
        KALMAN.state = newState;
        KALMAN.P = newP;
    }
    
    /**
     * Obtenir l'√©tat filtr√©
     */
    function kalmanGetState() {
        return {
            x: KALMAN.state[0],
            y: KALMAN.state[1],
            z: KALMAN.state[2],
            vx: KALMAN.state[3],
            vy: KALMAN.state[4],
            vz: KALMAN.state[5]
        };
    }
    
    /**
     * Inversion matrice 3x3
     */
    function invert3x3(M) {
        const det = M[0][0]*(M[1][1]*M[2][2] - M[1][2]*M[2][1])
                  - M[0][1]*(M[1][0]*M[2][2] - M[1][2]*M[2][0])
                  + M[0][2]*(M[1][0]*M[2][1] - M[1][1]*M[2][0]);
        
        if (Math.abs(det) < EPSILON) return null;
        
        const invDet = 1 / det;
        return [
            [(M[1][1]*M[2][2] - M[1][2]*M[2][1])*invDet, (M[0][2]*M[2][1] - M[0][1]*M[2][2])*invDet, (M[0][1]*M[1][2] - M[0][2]*M[1][1])*invDet],
            [(M[1][2]*M[2][0] - M[1][0]*M[2][2])*invDet, (M[0][0]*M[2][2] - M[0][2]*M[2][0])*invDet, (M[0][2]*M[1][0] - M[0][0]*M[1][2])*invDet],
            [(M[1][0]*M[2][1] - M[1][1]*M[2][0])*invDet, (M[0][1]*M[2][0] - M[0][0]*M[2][1])*invDet, (M[0][0]*M[1][1] - M[0][1]*M[1][0])*invDet]
        ];
    }
    
    // ============================================================
    // RANSAC - √âlimination des TDOA aberrants
    // ============================================================
    // S√©lectionne al√©atoirement des sous-ensembles de TDOA,
    // calcule une solution, et √©limine les outliers
    // ============================================================
    
    const RANSAC = {
        enabled: true,
        iterations: 20,          // Nombre d'it√©rations RANSAC
        inlierThreshold: 3.0,    // Distance max pour √™tre inlier (m)
        minInlierRatio: 0.6,     // Ratio minimum d'inliers requis
        
        // R√©sultats
        bestInliers: [],
        outlierSensors: [],      // Indices des capteurs probl√©matiques
        lastInlierRatio: 1.0
    };
    
    /**
     * Filtrage RANSAC des TDOA
     * @param {Array} tdoas - Liste des TDOA
     * @param {Array} toas - Temps d'arriv√©e bruts
     * @returns {object} TDOA filtr√©s + info outliers
     */
    function ransacFilterTDOA(tdoas, toas) {
        if (!RANSAC.enabled) {
            return { tdoas: tdoas, toas: toas, outliers: [], inlierRatio: 1.0 };
        }
        
        const n = toas.length; // 5 capteurs
        let bestSolution = null;
        let bestInliers = [];
        let bestInlierCount = 0;
        
        // It√©rations RANSAC
        for (let iter = 0; iter < RANSAC.iterations; iter++) {
            // S√©lectionner 4 capteurs al√©atoires (minimum pour solution 3D)
            const indices = [0, 1, 2, 3, 4];
            shuffleArray(indices);
            const sampleIndices = indices.slice(0, 4);
            
            // Construire TDOA partiel
            const sampleTDOAs = [];
            for (let i = 0; i < sampleIndices.length; i++) {
                for (let j = i + 1; j < sampleIndices.length; j++) {
                    const si = sampleIndices[i];
                    const sj = sampleIndices[j];
                    const tdoa = toas[si] - toas[sj];
                    sampleTDOAs.push({ i: si, j: sj, value: tdoa });
                }
            }
            
            // Calculer solution avec ce sous-ensemble
            try {
                const solution = locateDroneChanRANSAC(sampleTDOAs);
                if (!solution || !isFinite(solution.x)) continue;
                
                // Compter les inliers (capteurs coh√©rents avec cette solution)
                const inliers = [];
                const expectedTOAs = [];
                
                for (let i = 0; i < n; i++) {
                    const s = SENSORS[i];
                    const dist = Math.sqrt(
                        (solution.x - s.x)**2 + 
                        (solution.y - s.y)**2 + 
                        (solution.z - s.z)**2
                    );
                    expectedTOAs[i] = dist / SPEED_OF_SOUND;
                }
                
                // V√©rifier coh√©rence de chaque TDOA
                for (const tdoa of tdoas) {
                    const expectedTDOA = expectedTOAs[tdoa.i] - expectedTOAs[tdoa.j];
                    const error = Math.abs(tdoa.value - expectedTDOA) * SPEED_OF_SOUND; // Erreur en m√®tres
                    
                    if (error < RANSAC.inlierThreshold) {
                        inliers.push(tdoa);
                    }
                }
                
                if (inliers.length > bestInlierCount) {
                    bestInlierCount = inliers.length;
                    bestInliers = inliers;
                    bestSolution = solution;
                }
            } catch (e) {
                continue;
            }
        }
        
        // Identifier les capteurs outliers
        const outlierSensors = new Set();
        const allTDOAIndices = new Set(tdoas.map(t => `${t.i}-${t.j}`));
        const inlierIndices = new Set(bestInliers.map(t => `${t.i}-${t.j}`));
        
        for (const tdoa of tdoas) {
            if (!inlierIndices.has(`${tdoa.i}-${tdoa.j}`)) {
                outlierSensors.add(tdoa.i);
                outlierSensors.add(tdoa.j);
            }
        }
        
        RANSAC.bestInliers = bestInliers;
        RANSAC.outlierSensors = Array.from(outlierSensors);
        RANSAC.lastInlierRatio = bestInliers.length / tdoas.length;
        
        // Si trop d'outliers, retourner les TDOA originaux
        if (RANSAC.lastInlierRatio < RANSAC.minInlierRatio) {
            return { tdoas: tdoas, toas: toas, outliers: [], inlierRatio: RANSAC.lastInlierRatio };
        }
        
        return {
            tdoas: bestInliers.length > 0 ? bestInliers : tdoas,
            toas: toas,
            outliers: RANSAC.outlierSensors,
            inlierRatio: RANSAC.lastInlierRatio,
            solution: bestSolution
        };
    }
    
    /**
     * Version simplifi√©e de Chan pour RANSAC (sans protection z√©nithale)
     */
    function locateDroneChanRANSAC(tdoas) {
        const d10 = getTDOA(tdoas, 1, 0) * SPEED_OF_SOUND;
        const d20 = getTDOA(tdoas, 2, 0) * SPEED_OF_SOUND;
        const d30 = getTDOA(tdoas, 3, 0) * SPEED_OF_SOUND;
        const d40 = getTDOA(tdoas, 4, 0) * SPEED_OF_SOUND;
        
        const di0 = [d10, d20, d30, d40];
        const A = [], B = [];
        
        for (let i = 1; i < 5; i++) {
            const Si = SENSORS[i];
            const S0 = SENSORS[0];
            const d = di0[i - 1];
            A.push([Si.x - S0.x, Si.y - S0.y, Si.z - S0.z, d]);
            const Si2 = Si.x**2 + Si.y**2 + Si.z**2;
            const S02 = S0.x**2 + S0.y**2 + S0.z**2;
            B.push(0.5 * (Si2 - S02 - d**2));
        }
        
        const result = solveLinearSystem4x4(A, B);
        return { x: result[0], y: result[1], z: result[2], r0: result[3] };
    }
    
    /**
     * M√©lange al√©atoire d'un tableau (Fisher-Yates)
     */
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }
    
    // ============================================================
    // MOD√àLE DE VENT R√âALISTE
    // ============================================================
    // Le vent est un perturbateur INCONNU pour l'estimateur
    // Il corrompt les TDOA de mani√®re asym√©trique
    // ============================================================
    
    const WIND_CONFIG = {
        enabled: true,
        // Param√®tres de base (modifiables via UI)
        baseSpeed: 20,           // km/h vitesse de r√©f√©rence √† z_ref
        baseDirection: 45,       // degr√©s (0=Nord, 90=Est)
        gustFactor: 1.3,         // facteur multiplicatif des rafales
        gustProbability: 0.02,   // probabilit√© de rafale par frame
        directionDriftRate: 5,   // degr√©s par minute de d√©rive
        
        // Profil vertical (couche limite atmosph√©rique)
        z_ref: 10,               // hauteur de r√©f√©rence (m)
        z0: 0.1,                 // rugosit√© de surface (m) - terrain plat
        
        // √âtat dynamique
        currentSpeed: 20,        // km/h instantan√©
        currentDirection: 45,    // degr√©s instantan√©
        isGusting: false,
        gustTimer: 0,
        gustDuration: 0,
        directionChangeTimer: 0,
        targetDirection: 45,
        
        // Historique pour affichage
        history: []
    };
    
    /**
     * Profil logarithmique du vent en fonction de l'altitude
     * Loi de Prandtl pour la couche limite atmosph√©rique
     * 
     * @param {number} z - Altitude en m√®tres
     * @returns {number} Vitesse du vent √† l'altitude z (km/h)
     */
    function windSpeedAtAltitude(z) {
        const cfg = WIND_CONFIG;
        if (z < cfg.z0) z = cfg.z0;
        
        // v(z) = v_ref √ó ln(z/z0) / ln(z_ref/z0)
        const logRatio = Math.log(z / cfg.z0) / Math.log(cfg.z_ref / cfg.z0);
        return cfg.currentSpeed * logRatio;
    }
    
    /**
     * Obtenir le vecteur vent √† une altitude donn√©e
     * 
     * @param {number} z - Altitude en m√®tres
     * @returns {object} {vx, vy, speed, direction} en m/s et degr√©s
     */
    function getWindVector(z) {
        const speedKmh = windSpeedAtAltitude(z);
        const speedMs = speedKmh / 3.6;
        const dirRad = WIND_CONFIG.currentDirection * Math.PI / 180;
        
        // Convention: direction = d'o√π vient le vent
        // Donc le vecteur vitesse du vent va dans la direction oppos√©e
        const vx = -speedMs * Math.sin(dirRad);
        const vy = -speedMs * Math.cos(dirRad);
        
        return {
            vx: vx,
            vy: vy,
            vz: 0,  // Pas de composante verticale pour simplifier
            speed: speedMs,
            speedKmh: speedKmh,
            direction: WIND_CONFIG.currentDirection
        };
    }
    
    /**
     * Mise √† jour dynamique du vent (appel√©e chaque frame)
     */
    function updateWind(dt) {
        const cfg = WIND_CONFIG;
        if (!cfg.enabled) return;
        
        // === Gestion des rafales ===
        if (cfg.isGusting) {
            cfg.gustTimer += dt;
            if (cfg.gustTimer >= cfg.gustDuration) {
                // Fin de rafale
                cfg.isGusting = false;
                cfg.currentSpeed = cfg.baseSpeed;
            }
        } else {
            // Probabilit√© de d√©clencher une rafale
            if (Math.random() < cfg.gustProbability) {
                cfg.isGusting = true;
                cfg.gustTimer = 0;
                cfg.gustDuration = 1 + Math.random() * 3; // 1-4 secondes
                cfg.currentSpeed = cfg.baseSpeed * (cfg.gustFactor + Math.random() * 0.3);
                
                // La rafale peut aussi changer l√©g√®rement la direction
                cfg.currentDirection += (Math.random() - 0.5) * 30;
            }
        }
        
        // === D√©rive lente de la direction ===
        cfg.directionChangeTimer += dt;
        if (cfg.directionChangeTimer >= 60) { // Toutes les 60 secondes
            cfg.directionChangeTimer = 0;
            // Nouvelle direction cible
            cfg.targetDirection = cfg.baseDirection + (Math.random() - 0.5) * 60;
        }
        
        // Interpolation douce vers la direction cible
        const dirDiff = cfg.targetDirection - cfg.currentDirection;
        cfg.currentDirection += dirDiff * 0.01 * dt;
        
        // Normaliser direction [0, 360]
        cfg.currentDirection = ((cfg.currentDirection % 360) + 360) % 360;
        
        // === Fluctuations turbulentes (bruit haute fr√©quence) ===
        if (!cfg.isGusting) {
            // Petites variations autour de la vitesse de base
            const turbulence = (Math.random() - 0.5) * 0.1 * cfg.baseSpeed;
            cfg.currentSpeed = cfg.baseSpeed + turbulence;
        }
        
        // Historique pour affichage
        cfg.history.push({
            time: sim.time,
            speed: cfg.currentSpeed,
            direction: cfg.currentDirection,
            gusting: cfg.isGusting
        });
        if (cfg.history.length > 300) cfg.history.shift();
    }
    
    /**
     * Calcul du temps de propagation du son avec effet du vent
     * Le vent modifie la vitesse effective du son dans la direction de propagation
     * 
     * @param {object} source - Position de la source {x, y, z}
     * @param {object} receiver - Position du r√©cepteur {x, y, z}
     * @returns {number} Temps de propagation en secondes
     */
    function propagationTimeWithWind(source, receiver) {
        const dx = receiver.x - source.x;
        const dy = receiver.y - source.y;
        const dz = receiver.z - source.z;
        const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
        
        if (distance < 1e-6) return 0;
        
        if (!WIND_CONFIG.enabled) {
            return distance / SPEED_OF_SOUND;
        }
        
        // Direction unitaire de propagation (source vers receiver)
        const ux = dx / distance;
        const uy = dy / distance;
        const uz = dz / distance;
        
        // Vent moyen le long du trajet (approximation: vent √† altitude moyenne)
        const zMean = (source.z + receiver.z) / 2;
        const wind = getWindVector(zMean);
        
        // Composante du vent dans la direction de propagation
        // Positive = vent dans le sens de propagation (acc√©l√®re le son)
        // N√©gative = vent contraire (ralentit le son)
        const windComponent = wind.vx * ux + wind.vy * uy;
        
        // Vitesse effective du son
        const cEffective = SPEED_OF_SOUND + windComponent;
        
        // Protection contre vitesse effective n√©gative ou trop faible
        const cMin = SPEED_OF_SOUND * 0.5;
        const cFinal = Math.max(cMin, cEffective);
        
        return distance / cFinal;
    }
    
    // ============================================================
    // COH√âRENCE G√âOM√âTRIQUE TDOA
    // ============================================================
    // Analyse de la dispersion des solutions pour d√©tecter
    // et filtrer les perturbations (vent, bruit)
    // ============================================================
    
    const COHERENCE = {
        enabled: true,
        // R√©sultats de l'analyse
        solutions: [],           // 210 positions candidates
        centroid: {x: 0, y: 0, z: 0},
        dispersion: 0,           // √©cart-type 3D
        coherenceIndex: 100,     // 0-100%
        outlierTDOAs: [],        // indices des TDOA probl√©matiques
        confidenceEllipse: null, // pour affichage
        
        // Seuils
        convergenceThreshold: 5, // m√®tres - en dessous = bonne coh√©rence
        outlierSigma: 2,         // seuil pour d√©tection outliers
        minCoherence: 30,        // en dessous = alerte
        
        // Moyennage glissant (EMA) pour stabilit√©
        emaAlpha: 0.3,           // Facteur de lissage (0.3 = r√©actif, 0.1 = stable)
        coherenceEMA: 100,       // Coh√©rence liss√©e
        dispersionEMA: 0,        // Dispersion liss√©e
        
        // Historique pour analyse de tendance
        history: [],
        historyMaxLen: 30        // ~1 seconde √† 30fps
    };
    
    /**
     * G√©n√©rer toutes les combinaisons de k √©l√©ments parmi n
     */
    function combinations(arr, k) {
        const result = [];
        
        function combine(start, combo) {
            if (combo.length === k) {
                result.push([...combo]);
                return;
            }
            for (let i = start; i < arr.length; i++) {
                combo.push(arr[i]);
                combine(i + 1, combo);
                combo.pop();
            }
        }
        
        combine(0, []);
        return result;
    }
    
    /**
     * G√©n√©rer les 10 paires TDOA √† partir de 5 capteurs
     * @returns {Array} Liste des paires {i, j, tdoa}
     */
    function generateTDOAPairs(toas) {
        const pairs = [];
        const n = toas.length;
        
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
                pairs.push({
                    i: i,
                    j: j,
                    tdoa: toas[i] - toas[j],
                    pairIndex: pairs.length
                });
            }
        }
        return pairs;
    }
    
    /**
     * R√©soudre Chan avec un sous-ensemble de 4 TDOA
     * Version simplifi√©e pour analyse de coh√©rence
     */
    function solveChanSubset(tdoaPairs, subsetIndices, sensors) {
        // Extraire les 4 paires s√©lectionn√©es
        const selectedPairs = subsetIndices.map(idx => tdoaPairs[idx]);
        
        // Construction du syst√®me lin√©aire simplifi√©
        // Pour 4 TDOA, on a un syst√®me surd√©termin√© qu'on r√©sout par moindres carr√©s
        
        try {
            // Utiliser le premier capteur comme r√©f√©rence
            const ref = sensors[0];
            const c = SPEED_OF_SOUND;
            
            // Construire matrices pour moindres carr√©s
            const A = [];
            const b = [];
            
            for (const pair of selectedPairs) {
                const si = sensors[pair.i];
                const sj = sensors[pair.j];
                const d_ij = pair.tdoa * c; // distance diff√©rentielle
                
                // √âquation lin√©aris√©e (approximation)
                A.push([
                    2 * (sj.x - si.x),
                    2 * (sj.y - si.y),
                    2 * (sj.z - si.z)
                ]);
                
                const ri2 = si.x*si.x + si.y*si.y + si.z*si.z;
                const rj2 = sj.x*sj.x + sj.y*sj.y + sj.z*sj.z;
                b.push(d_ij*d_ij + ri2 - rj2);
            }
            
            // R√©solution par pseudo-inverse (A^T A)^-1 A^T b
            const pos = solveLinearSystem(A, b);
            
            if (pos && isFinite(pos.x) && isFinite(pos.y) && isFinite(pos.z)) {
                // V√©rifier que la solution est physiquement raisonnable
                const dist = Math.sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z);
                if (dist < 500 && pos.z > -10 && pos.z < 200) {
                    return pos;
                }
            }
        } catch (e) {
            // Solution invalide
        }
        
        return null;
    }
    
    /**
     * R√©solution syst√®me lin√©aire par moindres carr√©s
     */
    function solveLinearSystem(A, b) {
        const m = A.length;
        const n = A[0].length;
        
        // A^T * A
        const AtA = [];
        for (let i = 0; i < n; i++) {
            AtA[i] = [];
            for (let j = 0; j < n; j++) {
                let sum = 0;
                for (let k = 0; k < m; k++) {
                    sum += A[k][i] * A[k][j];
                }
                AtA[i][j] = sum;
            }
        }
        
        // A^T * b
        const Atb = [];
        for (let i = 0; i < n; i++) {
            let sum = 0;
            for (let k = 0; k < m; k++) {
                sum += A[k][i] * b[k];
            }
            Atb[i] = sum;
        }
        
        // R√©solution par √©limination de Gauss
        const x = gaussianElimination(AtA, Atb);
        
        if (x) {
            return { x: x[0], y: x[1], z: x[2] };
        }
        return null;
    }
    
    /**
     * √âlimination de Gauss avec pivot partiel
     */
    function gaussianElimination(A, b) {
        const n = A.length;
        const aug = A.map((row, i) => [...row, b[i]]);
        
        for (let col = 0; col < n; col++) {
            // Pivot partiel
            let maxRow = col;
            for (let row = col + 1; row < n; row++) {
                if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
                    maxRow = row;
                }
            }
            [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];
            
            if (Math.abs(aug[col][col]) < 1e-10) return null;
            
            // √âlimination
            for (let row = col + 1; row < n; row++) {
                const factor = aug[row][col] / aug[col][col];
                for (let j = col; j <= n; j++) {
                    aug[row][j] -= factor * aug[col][j];
                }
            }
        }
        
        // Substitution arri√®re
        const x = new Array(n);
        for (let i = n - 1; i >= 0; i--) {
            x[i] = aug[i][n];
            for (let j = i + 1; j < n; j++) {
                x[i] -= aug[i][j] * x[j];
            }
            x[i] /= aug[i][i];
        }
        
        return x;
    }
    
    /**
     * Analyse de coh√©rence g√©om√©trique compl√®te
     * √âvalue la dispersion des 210 solutions possibles
     */
    function analyzeGeometricCoherence(toas, sensors) {
        if (!COHERENCE.enabled) {
            return { valid: true, position: null, coherence: 100 };
        }
        
        // G√©n√©rer les 10 paires TDOA
        const tdoaPairs = generateTDOAPairs(toas);
        
        // G√©n√©rer les C(10,4) = 210 combinaisons de 4 paires
        const pairIndices = Array.from({length: 10}, (_, i) => i);
        const allCombinations = combinations(pairIndices, 4);
        
        // R√©soudre pour chaque combinaison
        const validSolutions = [];
        const solutionMap = new Map(); // Pour tracker quelles paires donnent quels r√©sultats
        
        for (const combo of allCombinations) {
            const solution = solveChanSubset(tdoaPairs, combo, sensors);
            if (solution) {
                solution.pairsUsed = combo;
                validSolutions.push(solution);
            }
        }
        
        COHERENCE.solutions = validSolutions;
        
        if (validSolutions.length < 10) {
            // Pas assez de solutions valides
            COHERENCE.coherenceIndex = 0;
            COHERENCE.dispersion = Infinity;
            return { valid: false, position: null, coherence: 0 };
        }
        
        // Calculer le centro√Øde (m√©dian pour robustesse)
        const xs = validSolutions.map(s => s.x).sort((a,b) => a-b);
        const ys = validSolutions.map(s => s.y).sort((a,b) => a-b);
        const zs = validSolutions.map(s => s.z).sort((a,b) => a-b);
        
        const medianIdx = Math.floor(validSolutions.length / 2);
        const centroid = {
            x: xs[medianIdx],
            y: ys[medianIdx],
            z: zs[medianIdx]
        };
        COHERENCE.centroid = centroid;
        
        // Calculer la dispersion (√©cart-type 3D)
        let sumSqDist = 0;
        const distances = [];
        for (const sol of validSolutions) {
            const dist = Math.sqrt(
                (sol.x - centroid.x)**2 +
                (sol.y - centroid.y)**2 +
                (sol.z - centroid.z)**2
            );
            distances.push(dist);
            sumSqDist += dist * dist;
        }
        
        const dispersion = Math.sqrt(sumSqDist / validSolutions.length);
        COHERENCE.dispersion = dispersion;
        
        // Calculer l'indice de coh√©rence (0-100%)
        // 100% si dispersion = 0, d√©cro√Æt exponentiellement
        const coherenceRaw = Math.max(0, Math.min(100, 
            100 * Math.exp(-dispersion / COHERENCE.convergenceThreshold)
        ));
        
        // =====================================================
        // MOYENNAGE GLISSANT (EMA) - Stabilisation
        // √âvite les oscillations dues au bruit ou feuilles
        // =====================================================
        const alpha = COHERENCE.emaAlpha;
        COHERENCE.coherenceEMA = alpha * coherenceRaw + (1 - alpha) * COHERENCE.coherenceEMA;
        COHERENCE.dispersionEMA = alpha * dispersion + (1 - alpha) * COHERENCE.dispersionEMA;
        
        // Utiliser la valeur liss√©e pour les d√©cisions
        const coherence = COHERENCE.coherenceEMA;
        COHERENCE.coherenceIndex = coherence;
        
        // Historique pour analyse de tendance
        COHERENCE.history.push({
            time: sim.time,
            raw: coherenceRaw,
            ema: coherence,
            dispersion: dispersion
        });
        if (COHERENCE.history.length > COHERENCE.historyMaxLen) {
            COHERENCE.history.shift();
        }
        
        // D√©tecter les outliers
        const threshold = dispersion * COHERENCE.outlierSigma;
        const outlierSolutions = validSolutions.filter((sol, idx) => distances[idx] > threshold);
        
        // Identifier les TDOA probl√©matiques (celles qui reviennent souvent dans les outliers)
        const tdoaOutlierCount = new Array(10).fill(0);
        for (const outlier of outlierSolutions) {
            for (const pairIdx of outlier.pairsUsed) {
                tdoaOutlierCount[pairIdx]++;
            }
        }
        
        // Normaliser par le nombre d'apparitions possibles
        const maxCount = Math.max(...tdoaOutlierCount);
        COHERENCE.outlierTDOAs = tdoaOutlierCount.map((count, idx) => ({
            pairIndex: idx,
            pair: tdoaPairs[idx],
            outlierScore: maxCount > 0 ? count / maxCount : 0
        })).filter(t => t.outlierScore > 0.5);
        
        // Calculer l'ellipse de confiance (approximation 2D pour affichage)
        const covXY = calculateCovariance2D(validSolutions);
        COHERENCE.confidenceEllipse = covXY;
        
        return {
            valid: coherence > COHERENCE.minCoherence,
            position: centroid,
            coherence: coherence,
            coherenceRaw: coherenceRaw,
            dispersion: dispersion,
            outlierTDOAs: COHERENCE.outlierTDOAs
        };
    }
    
    /**
     * Calcul de la matrice de covariance 2D pour l'ellipse de confiance
     */
    function calculateCovariance2D(solutions) {
        if (solutions.length < 2) return null;
        
        const n = solutions.length;
        const meanX = solutions.reduce((s, p) => s + p.x, 0) / n;
        const meanY = solutions.reduce((s, p) => s + p.y, 0) / n;
        
        let varX = 0, varY = 0, covXY = 0;
        for (const p of solutions) {
            const dx = p.x - meanX;
            const dy = p.y - meanY;
            varX += dx * dx;
            varY += dy * dy;
            covXY += dx * dy;
        }
        
        varX /= n;
        varY /= n;
        covXY /= n;
        
        // Valeurs propres pour les axes de l'ellipse
        const trace = varX + varY;
        const det = varX * varY - covXY * covXY;
        const discriminant = Math.sqrt(Math.max(0, trace * trace / 4 - det));
        
        const lambda1 = trace / 2 + discriminant;
        const lambda2 = trace / 2 - discriminant;
        
        // Angle de l'ellipse
        const angle = 0.5 * Math.atan2(2 * covXY, varX - varY);
        
        return {
            centerX: meanX,
            centerY: meanY,
            radiusX: Math.sqrt(lambda1) * 2,  // 2-sigma
            radiusY: Math.sqrt(Math.max(0.1, lambda2)) * 2,
            angle: angle
        };
    }
    
    // ============================================================
    // MOD√àLE ACOUSTIQUE
    // ============================================================
    // - Att√©nuation g√©om√©trique 1/r¬≤ 
    // - Effet du vent sur la propagation
    // - SNR = niveau re√ßu - bruit de fond
    // ============================================================
    
    // Types de terrain avec bruit de fond associ√© (dB)
    const TERRAIN_TYPES = {
        'water': { name: 'Eau / Lac', noise: 25 },
        'forest': { name: 'For√™t', noise: 30 },
        'country': { name: 'Campagne', noise: 35 },
        'suburban': { name: 'P√©riurbain', noise: 45 },
        'urban': { name: 'Urbain', noise: 55 },
        'industrial': { name: 'Industriel', noise: 60 }
    };
    
    // Types de drones avec niveau sonore SPL @ 1m (mesures terrain)
    const DRONE_TYPES = {
        'mini': { name: 'Mini (250g)', lwa: 74 },
        'consumer': { name: 'Consumer (600g)', lwa: 79 },
        'prosumer': { name: 'Prosumer (1.2kg)', lwa: 83 },
        'pro': { name: 'Pro (3kg)', lwa: 87 },
        'heavy': { name: 'Lourd (5kg)', lwa: 90 },
        'fpv': { name: 'FPV Racing', lwa: 95 }
    };
    
    const ACOUSTIC = {
        droneType: 'consumer',
        terrainType: 'country',
        backgroundNoise: 35,         // dB depuis terrain
        
        // Effet du vent sur propagation (dB par 100m)
        windEffectFavorable: -4,     // Vent porte le son ‚Üí moins d'att√©nuation
        windEffectAdverse: +5,       // Vent contraire ‚Üí plus d'att√©nuation
        
        // Seuils
        detectionThreshold: 3,       // dB SNR min pour d√©tecter
        
        // √âtat calcul√©
        currentSNR: 0,
        detectionBubble: []          // Contour de la bulle
    };
    
    /**
     * Calculer le niveau sonore re√ßu (dB) √† une distance donn√©e
     * Formule: Lp(r) = SPL_1m - 20¬∑log‚ÇÅ‚ÇÄ(r) + windEffect
     */
    function calculateReceivedLevel(distance, angleToWind) {
        // Protection contre distance nulle ou n√©gative
        distance = Math.max(distance, EPSILON_DISTANCE);
        
        const SPL_1m = DRONE_TYPES[ACOUSTIC.droneType].lwa; // SPL @ 1m (pas LWA)
        
        // Att√©nuation g√©om√©trique pure (1/r¬≤) - prot√©g√©e par EPSILON_DISTANCE
        const geometricLoss = 20 * Math.log10(distance);
        
        // V√©rification NaN/Infinity
        if (!isFinite(geometricLoss)) {
            console.warn('calculateReceivedLevel: geometricLoss invalide, distance=', distance);
            return SPL_1m; // Retourner niveau source par d√©faut
        }
        
        // Effet du vent
        let windEffect = 0;
        if (WIND_CONFIG.enabled && WIND_CONFIG.currentSpeed > 5) {
            const windFactor = Math.cos(angleToWind);
            const windStrength = Math.min(1, WIND_CONFIG.currentSpeed / 50);
            
            if (windFactor > 0) {
                // Vent favorable (drone ‚Üí r√©cepteur)
                windEffect = ACOUSTIC.windEffectFavorable * windStrength * windFactor * (distance / 100);
            } else {
                // Vent contraire
                windEffect = ACOUSTIC.windEffectAdverse * windStrength * Math.abs(windFactor) * (distance / 100);
            }
        }
        
        const result = SPL_1m - geometricLoss + windEffect;
        return isFinite(result) ? result : SPL_1m;
    }
    
    /**
     * Calculer le SNR pour la position actuelle du drone
     */
    function calculateSNR(dronePos) {
        const distance = Math.sqrt(dronePos.x**2 + dronePos.y**2 + dronePos.z**2);
        
        // Angle entre direction drone‚Üír√©cepteur et vent
        const dirToRx = Math.atan2(-dronePos.y, -dronePos.x);
        const windDirRad = (WIND_CONFIG.currentDirection - 180) * Math.PI / 180;
        const angleToWind = dirToRx - windDirRad;
        
        const receivedLevel = calculateReceivedLevel(distance, angleToWind);
        const SNR = receivedLevel - ACOUSTIC.backgroundNoise;
        
        ACOUSTIC.currentSNR = SNR;
        
        return {
            distance: distance,
            receivedLevel: receivedLevel,
            SNR: SNR,
            detectable: SNR >= ACOUSTIC.detectionThreshold
        };
    }
    
    /**
     * Calculer la bulle de d√©tection dynamique
     * Retourne les points du contour (d√©pend du vent)
     */
    function calculateDetectionBubble() {
        const points = [];
        const numPoints = 36;
        
        const SPL_1m = DRONE_TYPES[ACOUSTIC.droneType].lwa;
        const targetSNR = ACOUSTIC.detectionThreshold;
        const targetLevel = ACOUSTIC.backgroundNoise + targetSNR;
        
        for (let i = 0; i < numPoints; i++) {
            const angle = (i / numPoints) * 2 * Math.PI;
            
            // Direction de propagation
            const dirToRx = angle + Math.PI;
            const windDirRad = (WIND_CONFIG.currentDirection - 180) * Math.PI / 180;
            const angleToWind = dirToRx - windDirRad;
            
            // R√©solution it√©rative (windEffect d√©pend de r)
            let r = 100;
            for (let iter = 0; iter < 5; iter++) {
                let windEffect = 0;
                if (WIND_CONFIG.enabled && WIND_CONFIG.currentSpeed > 5) {
                    const windFactor = Math.cos(angleToWind);
                    const windStrength = Math.min(1, WIND_CONFIG.currentSpeed / 50);
                    if (windFactor > 0) {
                        windEffect = ACOUSTIC.windEffectFavorable * windStrength * windFactor * (r / 100);
                    } else {
                        windEffect = ACOUSTIC.windEffectAdverse * windStrength * Math.abs(windFactor) * (r / 100);
                    }
                }
                // Formule: SPL_1m - 20¬∑log‚ÇÅ‚ÇÄ(r) + windEffect = targetLevel
                r = Math.pow(10, (SPL_1m - targetLevel + windEffect) / 20);
            }
            
            r = Math.min(r, 500);
            r = Math.max(r, 10);
            
            points.push({
                angle: angle,
                range: r,
                x: r * Math.cos(angle),
                y: r * Math.sin(angle)
            });
        }
        
        ACOUSTIC.detectionBubble = points;
        return points;
    }
    
    const SENSORS = [
        { x: -0.5, y: -0.5, z: 0.0 },
        { x:  0.5, y: -0.5, z: 0.0 },
        { x:  0.5, y:  0.5, z: 0.0 },
        { x: -0.5, y:  0.5, z: 0.0 },
        { x:  0.0, y:  0.0, z: 0.636 }
    ];
    
    // ============================================================
    // √âTAT
    // ============================================================
    let sim = {
        running: false,
        time: 0,
        timeScale: 1.0, // 1.0 normal, 0.3 slowmo
        
        drone: { x: 0, y: 0, z: 40, vx: 0, vy: 0, vz: 0, speed: 12 },
        traceReal: [],
        traceEst: [],
        
        est: {
            azimuth: 0, elevation: 0,
            distance: 100, distanceGeom: 100, distanceIntegrated: 100,
            x: 80, y: 0, z: 40, // Position cart√©sienne estim√©e
            radialVelocity: 0, lastRadialVelocity: 0,
            azEMA: { f: 0, m: 0, s: 0 },
            elEMA: { f: 0, m: 0, s: 0 },
            distEMA: { f: 100, m: 100, s: 100 },
            azBuffer: [], elBuffer: [],
            count: 0,
            dopplerIntegrating: false // Flag pour UI
        },
        
        fireControl: {
            mode: 'kheops',
            cameraAz: 0, cameraEl: 0,
            tracking: false, lockOn: false,
            shotsFired: 0, lastShotTime: 0, shotCooldown: 0.3,
            targetCentered: false, droneDestroyed: false,
            respawnTimer: 0
        },
        
        // Stats globales
        stats: {
            totalKills: 0,
            totalShots: 0
        }
    };
    
    let map, mapOverlay, ctxMap;
    let canvasSide, ctxSide;
    let canvasCamera, ctxCamera;
    let canvasReticle, ctxReticle;
    // Variables de position Kh√©ops (modifiables)
    let rxLat = RX_LAT;
    let rxLon = RX_LON;
    let handoverCircle; // Cercle violet (handover)
    let bubbleCircle;   // Cercle cyan (bulle)
    let kheopsMarker;   // Marqueur central
    let animationId = null;
    
    // ============================================================
    // CONVERSION COORDONN√âES (g√©od√©sique pr√©cise)
    // ============================================================
    function metersToLatLon(x, y) {
        // Conversion locale autour du r√©cepteur
        const mPerDegLat = metersPerDegLat(rxLat);
        const mPerDegLon = metersPerDegLon(rxLat);
        return { 
            lat: rxLat + y / mPerDegLat, 
            lon: rxLon + x / mPerDegLon 
        };
    }
    
    function latLonToMeters(lat, lon) {
        const mPerDegLat = metersPerDegLat(rxLat);
        const mPerDegLon = metersPerDegLon(rxLat);
        return {
            x: (lon - rxLon) * mPerDegLon,
            y: (lat - rxLat) * mPerDegLat
        };
    }
    
    function normalize(v) {
        const m = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
        return m < 1e-10 ? { x: 0, y: 0, z: 1 } : { x: v.x/m, y: v.y/m, z: v.z/m };
    }
    
    function magnitude(v) { return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); }
    function dot(a, b) { return a.x*b.x + a.y*b.y + a.z*b.z; }
    
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1,3), 16);
        const g = parseInt(hex.slice(3,5), 16);
        const b = parseInt(hex.slice(5,7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }
    
    // ============================================================
    // INIT
    // ============================================================
    function init() {
        map = L.map('map', { center: [rxLat, rxLon], zoom: 17, zoomControl: true });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        bubbleCircle = L.circle([rxLat, rxLon], { radius: BUBBLE_RADIUS, color: '#00d4ff', fillOpacity: 0.05, weight: 2, dashArray: '5,5' }).addTo(map);
        handoverCircle = L.circle([rxLat, rxLon], { radius: HANDOVER_DISTANCE, color: '#ff00ff', fillOpacity: 0.08, weight: 2 }).addTo(map);
        kheopsMarker = L.circleMarker([rxLat, rxLon], { radius: 6, color: '#8b5cf6', fillColor: '#8b5cf6', fillOpacity: 1 }).addTo(map);
        
        // Clic sur la carte pour d√©placer Kh√©ops
        map.on('click', function(e) {
            rxLat = e.latlng.lat;
            rxLon = e.latlng.lng;
            // Mettre √† jour les cercles et le marqueur
            bubbleCircle.setLatLng([rxLat, rxLon]);
            handoverCircle.setLatLng([rxLat, rxLon]);
            kheopsMarker.setLatLng([rxLat, rxLon]);
        });
        
        mapOverlay = document.getElementById('mapOverlay');
        ctxMap = mapOverlay.getContext('2d');
        canvasSide = document.getElementById('canvasSide');
        ctxSide = canvasSide.getContext('2d');
        canvasCamera = document.getElementById('canvasCamera');
        ctxCamera = canvasCamera.getContext('2d');
        canvasReticle = document.getElementById('canvasReticle');
        ctxReticle = canvasReticle.getContext('2d');
        
        resizeCanvases();
        window.addEventListener('resize', resizeCanvases);
        map.on('move zoom', drawMapOverlay);
        
        // Initialiser le simulateur ADC 1 MHz
        initADC();
        
        spawnDrone();
        draw();
        
        // Initialiser l'affichage ISO 9613-1
        updateISODisplay();
    }
    
    function resizeCanvases() {
        const mapC = document.getElementById('mapContainer');
        mapOverlay.width = mapC.clientWidth;
        mapOverlay.height = mapC.clientHeight;
        
        [canvasSide, canvasCamera, canvasReticle].forEach(c => {
            const r = c.parentElement.getBoundingClientRect();
            c.width = r.width;
            c.height = r.height;
        });
        
        if (!sim.running) draw();
    }
    
    function spawnDrone() {
        const angle = Math.random() * 2 * Math.PI;
        const r = BUBBLE_RADIUS * 0.95;
        
        sim.drone.x = r * Math.cos(angle);
        sim.drone.y = r * Math.sin(angle);
        sim.drone.z = 25 + Math.random() * 30;
        
        const toCenter = normalize({ x: -sim.drone.x, y: -sim.drone.y, z: 0 });
        const dev = (Math.random() - 0.5) * Math.PI / 4;
        const c = Math.cos(dev), s = Math.sin(dev);
        
        sim.drone.vx = sim.drone.speed * (toCenter.x * c - toCenter.y * s);
        sim.drone.vy = sim.drone.speed * (toCenter.x * s + toCenter.y * c);
        sim.drone.vz = 0;
        
        const realDist = magnitude(sim.drone);
        
        // Reset estimateur - ON NE TRICHE PAS !
        // D√©part aveugle : azimuth=0, elevation=0, distance arbitraire
        sim.est = {
            azimuth: 0,
            elevation: 0,
            distance: 80, // Distance arbitraire, pas bas√©e sur realDist
            distanceGeom: 80,
            distanceIntegrated: 80,
            radialVelocity: 0, lastRadialVelocity: 0,
            azEMA: { f: 0, m: 0, s: 0 },
            elEMA: { f: 0, m: 0, s: 0 },
            distEMA: { f: 80, m: 80, s: 80 },
            azBuffer: [], elBuffer: [],
            count: 0,
            dopplerIntegrating: false,
            signalLost: true,           // Pas de signal au d√©part
            lastValidTime: 0,           // Derni√®re fois qu'on avait un signal
            signalLostDuration: 0,      // Dur√©e sans signal
            dopplerValid: true,
            ransacInlierRatio: 1.0,
            ransacOutliers: []
        };
        
        // Reset Kalman
        if (KALMAN.enabled) {
            kalmanInit();
            // Initialiser avec position estim√©e initiale
            KALMAN.state = [80, 0, 40, 0, 0, 0];
        }
        
        // Reset RANSAC
        RANSAC.bestInliers = [];
        RANSAC.outlierSensors = [];
        RANSAC.lastInlierRatio = 1.0;
        
        // Reset Coh√©rence EMA
        COHERENCE.coherenceEMA = 100;
        COHERENCE.dispersionEMA = 0;
        COHERENCE.history = [];
        
        // Reset ADC buffers
        initADC();
        
        sim.fireControl = {
            mode: 'kheops',
            cameraAz: 0, cameraEl: 0,
            tracking: false, lockOn: false,
            visualContact: false, // La cam√©ra a-t-elle vu le drone r√©el ?
            shotsFired: 0, lastShotTime: 0, shotCooldown: 0.3,
            targetCentered: false, droneDestroyed: false,
            respawnTimer: 0
        };
        
        sim.traceReal = [];
        sim.traceEst = [];
        sim.timeScale = 1.0;
    }
    
    // ============================================================
    // ESTIMATION TDOA AVEC EFFET DU VENT
    // ============================================================
    
    /**
     * Calcul des TOA R√âELS (affect√©s par le vent - inconnu de l'estimateur)
     */
    function computeTDOA_Real(pos) {
        // TOA r√©els avec effet du vent
        const toa = SENSORS.map(s => {
            return propagationTimeWithWind(pos, s);
        });
        
        const tdoas = [];
        for (let i = 0; i < 5; i++) {
            for (let j = i + 1; j < 5; j++) {
                tdoas.push({ i, j, value: toa[i] - toa[j] });
            }
        }
        return { tdoas, toa };
    }
    
    /**
     * Ancienne fonction (sans vent) - gard√©e pour comparaison
     */
    function computeTDOA(pos) {
        const toa = SENSORS.map(s => Math.sqrt((pos.x-s.x)**2 + (pos.y-s.y)**2 + (pos.z-s.z)**2) / SPEED_OF_SOUND);
        const tdoas = [];
        for (let i = 0; i < 5; i++) for (let j = i + 1; j < 5; j++) tdoas.push({ i, j, value: toa[i] - toa[j] });
        return { tdoas, toa };
    }
    
    // ============================================================
    // M√âTHODE DE CHAN - Solution analytique TDOA 3D
    // ============================================================
    
    function locateDroneChan(tdoas) {
        // Extraire les d_i0 = c * tau_i0 (distances diff√©rentielles par rapport √† S0)
        const d10 = getTDOA(tdoas, 1, 0) * SPEED_OF_SOUND; // R1 - R0
        const d20 = getTDOA(tdoas, 2, 0) * SPEED_OF_SOUND; // R2 - R0
        const d30 = getTDOA(tdoas, 3, 0) * SPEED_OF_SOUND; // R3 - R0
        const d40 = getTDOA(tdoas, 4, 0) * SPEED_OF_SOUND; // R4 - R0
        
        const di0 = [d10, d20, d30, d40];
        
        // =====================================================
        // D√âTECTION ZONE Z√âNITHALE
        // Quand le drone est au-dessus du r√©seau, les TDOA
        // des capteurs au sol (S0-S3) tendent vers 0
        // ‚Üí Matrice mal conditionn√©e ‚Üí erreur altitude massive
        // =====================================================
        const horizontalTDOASum = Math.abs(d10) + Math.abs(d20) + Math.abs(d30);
        const isNearZenith = horizontalTDOASum < 0.5; // Seuil ~0.5m de diff√©rence totale
        
        // Construire le syst√®me A * [x, y, z, R0]^T = B
        const A = [];
        const B = [];
        
        for (let i = 1; i < 5; i++) {
            const Si = SENSORS[i];
            const S0 = SENSORS[0];
            const d = di0[i - 1];
            
            // Ligne de A : [xi - x0, yi - y0, zi - z0, d_i0]
            A.push([
                Si.x - S0.x,
                Si.y - S0.y,
                Si.z - S0.z,
                d
            ]);
            
            // √âl√©ment de B : 0.5 * (|Si|¬≤ - |S0|¬≤ - d_i0¬≤)
            const Si2 = Si.x**2 + Si.y**2 + Si.z**2;
            const S02 = S0.x**2 + S0.y**2 + S0.z**2;
            B.push(0.5 * (Si2 - S02 - d**2));
        }
        
        // R√©soudre le syst√®me 4x4
        const result = solveLinearSystem4x4(A, B);
        
        let finalX = result[0];
        let finalY = result[1];
        let finalZ = result[2];
        let finalR0 = result[3];
        
        // =====================================================
        // CORRECTION Z√âNITHALE
        // En zone z√©nithale, X et Y sont proches de 0
        // On utilise le TOA du capteur S4 (z√©nithal) pour Z
        // =====================================================
        if (isNearZenith) {
            // Position horizontale : moyenne pond√©r√©e vers le centre
            // (les TDOA horizontaux sont peu fiables ici)
            finalX = result[0] * 0.3; // Att√©nuer les erreurs X
            finalY = result[1] * 0.3; // Att√©nuer les erreurs Y
            
            // Altitude : utiliser directement le TDOA S4-S0
            // d40 = R4 - R0, et si drone au z√©nith:
            // R4 ‚âà Z - h4 (distance au capteur z√©nithal)
            // R0 ‚âà Z (distance au capteur sol)
            // Donc d40 ‚âà -h4 ‚Üí Z ‚âà R0 ‚âà (R4 + h4)
            // 
            // M√©thode alternative: estimer Z depuis R0
            if (finalR0 > 0) {
                // R0¬≤ = X¬≤ + Y¬≤ + Z¬≤ ‚Üí Z = ‚àö(R0¬≤ - X¬≤ - Y¬≤)
                const r0sq = finalR0 * finalR0;
                const xySq = finalX * finalX + finalY * finalY;
                if (r0sq > xySq) {
                    finalZ = Math.sqrt(r0sq - xySq);
                }
            }
            
            // Fallback: si R0 invalide, utiliser le capteur S4
            if (finalZ <= 0 || !isFinite(finalZ)) {
                // TOA moyen des capteurs sol
                const toa0 = getTDOA(tdoas, 0, 0) || 0; // R√©f√©rence
                // Estimation depuis d40: Z ‚âà |d40| + hauteur_S4
                const S4 = SENSORS[4];
                finalZ = Math.abs(d40) + S4.z + 5; // +5m marge s√©curit√©
            }
        }
        
        // =====================================================
        // VALIDATION ET LISSAGE
        // =====================================================
        // V√©rifier coh√©rence de Z
        if (!isFinite(finalZ) || finalZ < 1) {
            finalZ = sim.est.z || 30; // Garder estimation pr√©c√©dente
        }
        
        // Limiter les variations brusques de Z (anti-spike)
        if (sim.est.z && Math.abs(finalZ - sim.est.z) > 50) {
            // Variation > 50m en une frame = aberrant
            finalZ = sim.est.z + Math.sign(finalZ - sim.est.z) * 5;
        }
        
        return {
            x: finalX,
            y: finalY,
            z: Math.max(1, finalZ), // Z >= 1m
            r0: finalR0,
            isZenith: isNearZenith
        };
    }
    
    // R√©cup√©rer un TDOA (g√®re l'ordre i,j ou j,i)
    function getTDOA(tdoas, i, j) {
        const direct = tdoas.find(t => t.i === i && t.j === j);
        if (direct) return direct.value;
        const inverse = tdoas.find(t => t.i === j && t.j === i);
        if (inverse) return -inverse.value;
        return 0;
    }
    
    // Solveur Gauss-Jordan pour syst√®me 4x4
    function solveLinearSystem4x4(A, B) {
        const n = 4;
        // Copier pour ne pas modifier les originaux
        const M = A.map(row => [...row]);
        const b = [...B];
        
        // √âlimination de Gauss avec pivot partiel
        for (let i = 0; i < n; i++) {
            // Chercher le pivot max
            let maxRow = i;
            for (let k = i + 1; k < n; k++) {
                if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
            }
            // √âchanger les lignes
            [M[i], M[maxRow]] = [M[maxRow], M[i]];
            [b[i], b[maxRow]] = [b[maxRow], b[i]];
            
            // V√©rifier pivot non nul
            if (Math.abs(M[i][i]) < 1e-12) continue;
            
            // √âlimination
            for (let j = i + 1; j < n; j++) {
                const factor = M[j][i] / M[i][i];
                b[j] -= factor * b[i];
                for (let k = i; k < n; k++) {
                    M[j][k] -= factor * M[i][k];
                }
            }
        }
        
        // Substitution arri√®re
        const x = new Array(n).fill(0);
        for (let i = n - 1; i >= 0; i--) {
            if (Math.abs(M[i][i]) < 1e-12) continue;
            let sum = 0;
            for (let k = i + 1; k < n; k++) {
                sum += M[i][k] * x[k];
            }
            x[i] = (b[i] - sum) / M[i][i];
        }
        
        return x;
    }
    
    function estimateDirection(tdoas) {
        const pairs = [{ i: 0, j: 1 }, { i: 0, j: 2 }, { i: 0, j: 3 }, { i: 0, j: 4 }];
        const A = [], b = [];
        for (const p of pairs) {
            const si = SENSORS[p.i], sj = SENSORS[p.j];
            A.push([sj.x - si.x, sj.y - si.y, sj.z - si.z]);
            b.push(tdoas.find(t => t.i === p.i && t.j === p.j).value * SPEED_OF_SOUND);
        }
        const dir = solveLeastSquares(A, b);
        const u = normalize({ x: dir[0], y: dir[1], z: dir[2] });
        return { azimuth: Math.atan2(u.y, u.x), elevation: Math.asin(Math.max(-1, Math.min(1, u.z))), u };
    }
    
    function solveLeastSquares(A, b) {
        const ATA = [[0,0,0],[0,0,0],[0,0,0]], ATb = [0,0,0];
        for (let i = 0; i < A.length; i++) {
            for (let j = 0; j < 3; j++) {
                ATb[j] += A[i][j] * b[i];
                for (let k = 0; k < 3; k++) ATA[j][k] += A[i][j] * A[i][k];
            }
        }
        return solve3x3(ATA, ATb);
    }
    
    function solve3x3(M, v) {
        const det = M[0][0]*(M[1][1]*M[2][2]-M[1][2]*M[2][1]) - M[0][1]*(M[1][0]*M[2][2]-M[1][2]*M[2][0]) + M[0][2]*(M[1][0]*M[2][1]-M[1][1]*M[2][0]);
        if (Math.abs(det) < 1e-12) return [0, 0, 1];
        const inv = [
            [(M[1][1]*M[2][2]-M[1][2]*M[2][1])/det, (M[0][2]*M[2][1]-M[0][1]*M[2][2])/det, (M[0][1]*M[1][2]-M[0][2]*M[1][1])/det],
            [(M[1][2]*M[2][0]-M[1][0]*M[2][2])/det, (M[0][0]*M[2][2]-M[0][2]*M[2][0])/det, (M[0][2]*M[1][0]-M[0][0]*M[1][2])/det],
            [(M[1][0]*M[2][1]-M[1][1]*M[2][0])/det, (M[0][1]*M[2][0]-M[0][0]*M[2][1])/det, (M[0][0]*M[1][1]-M[0][1]*M[1][0])/det]
        ];
        return [inv[0][0]*v[0]+inv[0][1]*v[1]+inv[0][2]*v[2], inv[1][0]*v[0]+inv[1][1]*v[1]+inv[1][2]*v[2], inv[2][0]*v[0]+inv[2][1]*v[1]+inv[2][2]*v[2]];
    }
    
    function estimateDistanceGeometric(toa, u) {
        let r = toa.reduce((a,b)=>a+b,0)/toa.length * SPEED_OF_SOUND;
        for (let iter = 0; iter < 5; iter++) {
            let sumErr = 0, sumGrad = 0;
            const px = r*u.x, py = r*u.y, pz = r*u.z;
            for (let i = 1; i < SENSORS.length; i++) {
                const s = SENSORS[i], s0 = SENSORS[0];
                const d = Math.sqrt((px-s.x)**2+(py-s.y)**2+(pz-s.z)**2);
                const d0 = Math.sqrt((px-s0.x)**2+(py-s0.y)**2+(pz-s0.z)**2);
                const err = (d-d0)/SPEED_OF_SOUND - (toa[i]-toa[0]);
                sumErr += err*err;
                sumGrad += 2*err*((u.x*(px-s.x)+u.y*(py-s.y)+u.z*(pz-s.z))/d - (u.x*(px-s0.x)+u.y*(py-s0.y)+u.z*(pz-s0.z))/d0)/SPEED_OF_SOUND;
            }
            if (Math.abs(sumGrad) > 1e-10) r -= 0.5*sumErr/sumGrad;
            r = Math.max(10, Math.min(BUBBLE_RADIUS*2, r));
        }
        return r;
    }
    
    function ema(old, newVal, period) { return 2/(period+1)*newVal + (1-2/(period+1))*old; }
    
    function updateEstimator() {
        const dronePos = sim.drone, vel = { x: dronePos.vx, y: dronePos.vy, z: dronePos.vz };
        const e = sim.est;
        const dt = BASE_DT * sim.timeScale;
        
        // =====================================================
        // √âTAPE 0: SIMULATION ADC 1 MHz
        // G√©n√®re les √©chantillons et remplit les buffers
        // =====================================================
        simulateADC(dronePos, dt);
        
        // =====================================================
        // √âTAPE 1: PR√âDICTION KALMAN
        // =====================================================
        if (KALMAN.enabled) {
            kalmanPredict(dt);
        }
        
        // =====================================================
        // √âTAPE 2: V√âRIFICATION SNR - Le drone est-il audible ?
        // =====================================================
        const snrInfo = calculateSNR(dronePos);
        
        if (snrInfo.SNR < ACOUSTIC.detectionThreshold) {
            e.signalLost = true;
            e.signalLostDuration += dt;
            
            if (KALMAN.enabled && KALMAN.initialized) {
                const kState = kalmanGetState();
                e.x = kState.x;
                e.y = kState.y;
                e.z = Math.max(MIN_ALTITUDE, kState.z);
                e.distance = Math.sqrt(e.x**2 + e.y**2 + e.z**2);
                e.azimuth = Math.atan2(e.y, e.x);
                e.elevation = Math.asin(Math.max(-1, Math.min(1, e.z / e.distance)));
            }
            return;
        }
        
        // =====================================================
        // √âTAPE 3: SIGNAL OK - Drone audible
        // =====================================================
        e.signalLost = false;
        e.lastValidTime = sim.time;
        e.signalLostDuration = 0;
        
        // =====================================================
        // √âTAPE 4: EXTRACTION TDOA
        // Via corr√©lation ADC (limit√© en fr√©quence), sinon th√©orique
        // =====================================================
        let rawTDOAs, toa;
        
        // SIMULATION: TDOA th√©oriques (le vrai hardware utilisera la corr√©lation)
        // En simulation, on ne peut pas simuler correctement le signal
        // car on part de la position pour g√©n√©rer le signal qu'on corr√®le
        // pour retrouver la position ‚Üí cercle vicieux d'approximations
        const USE_CORRELATION = false;
        
        ADC.correlationCounter++;
        const doCorrelation = USE_CORRELATION && ADC.tdoaReady && (ADC.correlationCounter % ADC.correlationInterval === 0);
        
        if (doCorrelation) {
            // TDOA par corr√©lation du signal r√©el simul√©
            rawTDOAs = extractTDOA_Correlation();
            e.tdoaMode = 'CORR';
            
            // Reconstruire TOA depuis TDOA (ref = capteur 0)
            toa = [0];
            for (let i = 1; i < ADC.channels; i++) {
                const pair = rawTDOAs.find(t => 
                    (t.i === 0 && t.j === i) || (t.i === i && t.j === 0)
                );
                if (pair) {
                    toa[i] = pair.i === 0 ? pair.value : -pair.value;
                } else {
                    toa[i] = 0;
                }
            }
            // Sauvegarder pour les frames suivantes
            ADC.lastTDOA = rawTDOAs;
            ADC.lastTOA = toa;
        } else if (doCorrelation && ADC.lastTDOA) {
            // R√©utiliser les derniers TDOA calcul√©s
            rawTDOAs = ADC.lastTDOA;
            toa = ADC.lastTOA;
            e.tdoaMode = 'CACHED';
        } else {
            // TDOA th√©orique (avec vent)
            const result = computeTDOA_Real(dronePos);
            rawTDOAs = result.tdoas;
            toa = result.toa;
            e.tdoaMode = 'THEO';
        }
        
        e.count++;
        
        // =====================================================
        // √âTAPE 5: FILTRAGE RANSAC DES TDOA
        // =====================================================
        const ransacResult = ransacFilterTDOA(rawTDOAs, toa);
        const tdoas = ransacResult.tdoas;
        
        e.ransacInlierRatio = ransacResult.inlierRatio;
        e.ransacOutliers = ransacResult.outliers;
        
        // =====================================================
        // √âTAPE 6: ANALYSE DE COH√âRENCE G√âOM√âTRIQUE (avec EMA)
        // =====================================================
        const coherenceResult = analyzeGeometricCoherence(toa, SENSORS);
        
        e.coherence = coherenceResult.coherence;
        e.coherenceRaw = coherenceResult.coherenceRaw || coherenceResult.coherence;
        e.dispersion = coherenceResult.dispersion || 0;
        e.coherenceValid = coherenceResult.valid;
        
        // =====================================================
        // √âTAPE 7: M√âTHODE DE CHAN - Solution analytique
        // =====================================================
        const chanResult = locateDroneChan(tdoas);
        e.isZenith = chanResult.isZenith || false;
        
        // Fusion Chan/Centro√Øde selon coh√©rence
        let rawX, rawY, rawZ;
        
        if (COHERENCE.enabled && coherenceResult.valid && coherenceResult.position) {
            const w = coherenceResult.coherence / 100;
            rawX = w * chanResult.x + (1 - w) * coherenceResult.position.x;
            rawY = w * chanResult.y + (1 - w) * coherenceResult.position.y;
            rawZ = w * chanResult.z + (1 - w) * coherenceResult.position.z;
        } else if (coherenceResult.coherence < COHERENCE.minCoherence && COHERENCE.centroid) {
            rawX = COHERENCE.centroid.x;
            rawY = COHERENCE.centroid.y;
            rawZ = COHERENCE.centroid.z;
        } else {
            rawX = chanResult.x;
            rawY = chanResult.y;
            rawZ = chanResult.z;
        }
        
        // Protection NaN
        if (!isFinite(rawX)) rawX = e.x || 0;
        if (!isFinite(rawY)) rawY = e.y || 0;
        if (!isFinite(rawZ)) rawZ = e.z || 30;
        rawZ = Math.max(MIN_ALTITUDE, Math.min(MAX_ALTITUDE, rawZ));
        
        // =====================================================
        // √âTAPE 8: MISE √Ä JOUR KALMAN
        // Fusionner la mesure acoustique avec la pr√©diction
        // =====================================================
        let finalX, finalY, finalZ;
        
        if (KALMAN.enabled) {
            // Ajuster le bruit de mesure selon la coh√©rence
            // Faible coh√©rence = haute incertitude sur la mesure
            const coherenceFactor = Math.max(0.1, coherenceResult.coherence / 100);
            const adaptiveNoise = KALMAN.measurementNoise / coherenceFactor;
            
            // Mise √† jour Kalman avec la mesure acoustique
            kalmanUpdate({ x: rawX, y: rawY, z: rawZ }, adaptiveNoise);
            
            // Utiliser l'√©tat filtr√©
            const kState = kalmanGetState();
            finalX = kState.x;
            finalY = kState.y;
            finalZ = kState.z;
            
            // Stocker info Kalman pour UI
            e.kalmanVx = kState.vx;
            e.kalmanVy = kState.vy;
            e.kalmanVz = kState.vz;
            e.kalmanInnovation = KALMAN.innovation;
        } else {
            finalX = rawX;
            finalY = rawY;
            finalZ = rawZ;
        }
        
        // Contraintes physiques finales
        finalZ = Math.max(MIN_ALTITUDE, Math.min(MAX_ALTITUDE, finalZ));
        
        // Position estim√©e filtr√©e
        e.x = finalX;
        e.y = finalY;
        e.z = finalZ;
        
        // Coordonn√©es sph√©riques
        e.distance = Math.sqrt(e.x**2 + e.y**2 + e.z**2);
        e.distance = Math.max(e.distance, EPSILON_DISTANCE);
        e.azimuth = Math.atan2(e.y, e.x);
        e.elevation = Math.asin(Math.max(-1, Math.min(1, e.z / e.distance)));
        
        // =====================================================
        // √âTAPE 9: VALIDATION CROIS√âE DOPPLER
        // Comparer vitesse Doppler vs vitesse g√©om√©trique
        // =====================================================
        const vRadDoppler = dot(vel, normalize({ x: -dronePos.x, y: -dronePos.y, z: -dronePos.z }));
        
        // Vitesse radiale g√©om√©trique (depuis Kalman ou diff√©rence de position)
        let vRadGeom = 0;
        if (KALMAN.enabled && KALMAN.initialized) {
            const kState = kalmanGetState();
            // Vitesse radiale = projection de (vx,vy,vz) sur direction radiale
            const dirToCenter = normalize({ x: -e.x, y: -e.y, z: -e.z });
            vRadGeom = kState.vx * dirToCenter.x + kState.vy * dirToCenter.y + kState.vz * dirToCenter.z;
        }
        
        // √âcart entre Doppler et g√©om√©trique
        const dopplerGeomDiff = Math.abs(vRadDoppler - vRadGeom);
        e.dopplerGeomDiff = dopplerGeomDiff;
        
        // Validation: si √©cart > seuil, les donn√©es sont incoh√©rentes
        const DOPPLER_GEOM_THRESHOLD = 5.0; // m/s d'√©cart max tol√©r√©
        
        if (Math.abs(vRadDoppler) > MAX_DRONE_SPEED) {
            // Doppler aberrant
            e.radialVelocity = e.lastRadialVelocity || 0;
            e.dopplerValid = false;
        } else if (dopplerGeomDiff > DOPPLER_GEOM_THRESHOLD && e.count > 10) {
            // Incoh√©rence Doppler/G√©om√©trie ‚Üí r√©duire la coh√©rence
            e.dopplerValid = false;
            e.coherence = Math.min(e.coherence, 50); // Forcer coh√©rence basse
            e.radialVelocity = (vRadDoppler + vRadGeom) / 2; // Moyenne
        } else {
            e.radialVelocity = vRadDoppler;
            e.lastRadialVelocity = vRadDoppler;
            e.dopplerValid = true;
        }
        
        // =====================================================
        // √âTAPE 10: COMPENSATION GHOSTING
        // =====================================================
        const propagationDelay = e.distance / SPEED_OF_SOUND;
        
        if (e.dopplerValid && Math.abs(e.radialVelocity) > DOPPLER_DEADZONE) {
            const correction = e.radialVelocity * propagationDelay;
            e.distancePredicted = Math.max(EPSILON_DISTANCE, e.distance - correction);
        } else {
            e.distancePredicted = e.distance;
        }
        
        // Position pr√©dite pour conduite de tir
        const predRatio = e.distancePredicted / e.distance;
        e.xPredicted = e.x * predRatio;
        e.yPredicted = e.y * predRatio;
        e.zPredicted = e.z * predRatio;
        
        // Compatibilit√© UI
        e.distanceGeom = e.distance;
        e.distanceIntegrated = e.distance;
        e.dopplerIntegrating = Math.abs(e.radialVelocity) >= DOPPLER_DEADZONE;
        e.propagationDelay = propagationDelay;
        e.ghostingCorrection = e.distance - e.distancePredicted;
    }
    
    // ============================================================
    // CONDUITE DE TIR
    // ============================================================
    function updateFireControl() {
        const fc = sim.fireControl;
        const e = sim.est;
        const dt = BASE_DT * sim.timeScale;
        
        // Respawn timer
        if (fc.droneDestroyed) {
            fc.respawnTimer += dt;
            if (fc.respawnTimer >= RESPAWN_DELAY) {
                spawnDrone();
            }
            return;
        }
        
        // Handover bas√© sur distance ESTIM√âE
        const wasCamera = fc.mode === 'camera';
        
        if (e.distance < HANDOVER_DISTANCE && fc.mode === 'kheops') {
            fc.mode = 'camera';
            fc.tracking = true;
            // Plus de slowmo
        } else if (e.distance >= HANDOVER_DISTANCE + 10 && fc.mode === 'camera') {
            fc.mode = 'kheops';
            fc.tracking = false;
            fc.lockOn = false;
            fc.visualContact = false;
        }
        
        // Mode cam√©ra - tracking
        if (fc.mode === 'camera' && fc.tracking) {
            const trackSpeed = 0.12;
            
            // Position R√âELLE du drone (ce que la cam√©ra voit vraiment)
            const realDist = magnitude(sim.drone);
            const realAz = Math.atan2(sim.drone.y, sim.drone.x);
            const realEl = Math.asin(sim.drone.z / realDist);
            
            // Au d√©but, la cam√©ra pointe vers l'estim√© (handover de Kh√©ops)
            // Mais d√®s qu'elle "voit" le drone r√©el, elle le track directement
            let targetAz, targetEl;
            
            // V√©rifier si le drone r√©el est dans le FOV actuel (~30¬∞)
            let azOffFromCam = realAz - fc.cameraAz;
            if (azOffFromCam > Math.PI) azOffFromCam -= 2*Math.PI;
            if (azOffFromCam < -Math.PI) azOffFromCam += 2*Math.PI;
            const elOffFromCam = realEl - fc.cameraEl;
            const inFOV = Math.abs(azOffFromCam) < Math.PI/6 && Math.abs(elOffFromCam) < Math.PI/6;
            
            if (inFOV || fc.visualContact) {
                // Cam√©ra voit le drone r√©el ‚Üí track le R√âEL
                fc.visualContact = true;
                targetAz = realAz;
                targetEl = realEl;
            } else {
                // Pas encore de contact visuel ‚Üí suivre l'estim√© (guidage Kh√©ops)
                targetAz = e.azimuth;
                targetEl = e.elevation;
            }
            
            let azDiff = targetAz - fc.cameraAz;
            if (azDiff > Math.PI) azDiff -= 2*Math.PI;
            if (azDiff < -Math.PI) azDiff += 2*Math.PI;
            const elDiff = targetEl - fc.cameraEl;
            
            fc.cameraAz += Math.max(-trackSpeed, Math.min(trackSpeed, azDiff * 0.25));
            fc.cameraEl += Math.max(-trackSpeed, Math.min(trackSpeed, elDiff * 0.25));
            
            // Lock bas√© sur le drone R√âEL (pas l'estim√©)
            let finalAzOff = realAz - fc.cameraAz;
            if (finalAzOff > Math.PI) finalAzOff -= 2*Math.PI;
            if (finalAzOff < -Math.PI) finalAzOff += 2*Math.PI;
            const finalElOff = realEl - fc.cameraEl;
            const angularError = Math.sqrt(finalAzOff*finalAzOff + finalElOff*finalElOff) * 180/Math.PI;
            
            fc.targetCentered = angularError < 3;
            fc.lockOn = angularError < 1.5;
            
            // TIR AUTO - utilise la distance PR√âDICTIVE (compensation ghosting)
            const effectiveDistance = e.distancePredicted || e.distance;
            if (fc.lockOn && effectiveDistance < HANDOVER_DISTANCE && sim.time - fc.lastShotTime > fc.shotCooldown) {
                const realDist = magnitude(sim.drone);
                const realAz = Math.atan2(sim.drone.y, sim.drone.x);
                const realEl = Math.asin(sim.drone.z / Math.max(realDist, EPSILON_DISTANCE));
                
                const aimError = Math.sqrt((fc.cameraAz - realAz)**2 + (fc.cameraEl - realEl)**2) * realDist;
                
                fc.shotsFired++;
                sim.stats.totalShots++;
                fc.lastShotTime = sim.time;
                
                // Log d√©taill√© pour analyse
                const ghostCorr = e.ghostingCorrection || 0;
                console.log(`TIR #${sim.stats.totalShots} | Dist: ${effectiveDistance.toFixed(1)}m | Ghost: ${ghostCorr.toFixed(2)}m | Aim: ${aimError.toFixed(2)}m`);
                
                if (aimError < SHOTGUN_SPREAD) {
                    fc.droneDestroyed = true;
                    fc.respawnTimer = 0;
                    sim.stats.totalKills++;
                    console.log(`‚úì KILL #${sim.stats.totalKills} - Erreur: ${aimError.toFixed(2)}m`);
                } else {
                    console.log(`‚úó MISS - Erreur: ${aimError.toFixed(2)}m > Spread: ${SHOTGUN_SPREAD}m`);
                }
            }
        }
    }
    
    // ============================================================
    // PHYSIQUE DRONE
    // ============================================================
    function updateDrone() {
        if (sim.fireControl.droneDestroyed) return;
        
        const d = sim.drone;
        const dt = BASE_DT * sim.timeScale;
        
        // =====================================================
        // COMPORTEMENT FPV AGRESSIF - Man≈ìuvres jusqu'√† 2g
        // =====================================================
        
        // Param√®tres de man≈ìuvre
        const maxG = 2.0;                    // Acc√©l√©ration max en g
        const g = 9.81;                      // m/s¬≤
        const maxAccel = maxG * g;           // ~20 m/s¬≤
        const maneuverFreq = 0.5;            // Probabilit√© de man≈ìuvre par seconde
        const maneuverDuration = 0.5 + Math.random() * 1.5; // 0.5 √† 2 secondes
        
        // Timer de man≈ìuvre
        if (!d.maneuverTimer) d.maneuverTimer = 0;
        if (!d.maneuverAccel) d.maneuverAccel = { x: 0, y: 0, z: 0 };
        if (!d.maneuverEnd) d.maneuverEnd = 0;
        
        d.maneuverTimer += dt;
        
        // D√©clencher une nouvelle man≈ìuvre ?
        if (sim.time > d.maneuverEnd && Math.random() < maneuverFreq * dt) {
            // Direction de man≈ìuvre al√©atoire (perpendiculaire √† la vitesse + Z)
            const speed = Math.sqrt(d.vx*d.vx + d.vy*d.vy);
            if (speed > 0.1) {
                // Vecteur perpendiculaire √† la vitesse (virage)
                const perpX = -d.vy / speed;
                const perpY = d.vx / speed;
                
                // Intensit√© al√©atoire (0.5g √† 2g)
                const intensity = (0.5 + Math.random() * 1.5) * g;
                const sign = Math.random() > 0.5 ? 1 : -1;
                
                d.maneuverAccel.x = perpX * intensity * sign;
                d.maneuverAccel.y = perpY * intensity * sign;
                d.maneuverAccel.z = (Math.random() - 0.5) * intensity; // Variation altitude
                
                d.maneuverEnd = sim.time + maneuverDuration;
            }
        }
        
        // Fin de man≈ìuvre ‚Üí d√©c√©l√©ration
        if (sim.time > d.maneuverEnd) {
            d.maneuverAccel.x *= 0.9;
            d.maneuverAccel.y *= 0.9;
            d.maneuverAccel.z *= 0.9;
        }
        
        // Appliquer l'acc√©l√©ration de man≈ìuvre
        d.vx += d.maneuverAccel.x * dt;
        d.vy += d.maneuverAccel.y * dt;
        d.vz += d.maneuverAccel.z * dt;
        
        // Tendance vers le centre (√©vite de sortir)
        const distXY = Math.sqrt(d.x*d.x + d.y*d.y);
        if (distXY > BUBBLE_RADIUS * 0.6) {
            const pullStrength = 2.0 * (distXY / BUBBLE_RADIUS);
            d.vx -= (d.x / distXY) * pullStrength * dt;
            d.vy -= (d.y / distXY) * pullStrength * dt;
        }
        
        // Limiter la vitesse max
        const currentSpeed = Math.sqrt(d.vx*d.vx + d.vy*d.vy + d.vz*d.vz);
        const maxSpeed = d.speed * 1.5; // 50% au-dessus de la vitesse nominale max
        if (currentSpeed > maxSpeed) {
            const scale = maxSpeed / currentSpeed;
            d.vx *= scale;
            d.vy *= scale;
            d.vz *= scale;
        }
        
        // Mise √† jour position
        d.x += d.vx * dt;
        d.y += d.vy * dt;
        d.z += d.vz * dt;
        
        // Rebond bulle (s√©curit√©)
        if (distXY > BUBBLE_RADIUS) {
            const nx = -d.x/distXY, ny = -d.y/distXY;
            const vn = d.vx*nx + d.vy*ny;
            d.vx -= 2*vn*nx; 
            d.vy -= 2*vn*ny;
            d.x = d.x / distXY * (BUBBLE_RADIUS - 1);
            d.y = d.y / distXY * (BUBBLE_RADIUS - 1);
        }
        
        // Rebond altitude
        if (d.z < 15) { d.z = 15; d.vz = Math.abs(d.vz)*0.8; }
        if (d.z > 80) { d.z = 80; d.vz = -Math.abs(d.vz)*0.8; }
    }
    
    function updateTraces() {
        const t = sim.time;
        if (!sim.fireControl.droneDestroyed) {
            sim.traceReal.push({ x: sim.drone.x, y: sim.drone.y, z: sim.drone.z, t });
        }
        const e = sim.est;
        sim.traceEst.push({ x: e.distance*Math.cos(e.azimuth)*Math.cos(e.elevation), y: e.distance*Math.sin(e.azimuth)*Math.cos(e.elevation), z: e.distance*Math.sin(e.elevation), t });
        
        const cutoff = t - TRACE_DURATION;
        sim.traceReal = sim.traceReal.filter(p => p.t > cutoff);
        sim.traceEst = sim.traceEst.filter(p => p.t > cutoff);
    }
    
    // ============================================================
    // DESSIN
    // ============================================================
    function draw() {
        drawMapOverlay();
        drawSide();
        drawCamera();
        drawReticle();
    }
    
    function drawMapOverlay() {
        const w = mapOverlay.width, h = mapOverlay.height;
        ctxMap.clearRect(0, 0, w, h);
        if (!map) return;
        
        function toPixel(lat, lon) {
            const p = map.latLngToContainerPoint([lat, lon]);
            return { x: p.x, y: p.y };
        }
        
        // =====================================================
        // BULLE DE D√âTECTION ACOUSTIQUE (forme selon vent)
        // =====================================================
        if (ACOUSTIC.detectionBubble.length > 0) {
            const centerPx = toPixel(rxLat, rxLon);
            
            // Conversion m√®tres ‚Üí pixels
            const testPoint = metersToLatLon(1, 0);
            const testPx = toPixel(testPoint.lat, testPoint.lon);
            const pixelsPerMeter = Math.sqrt((testPx.x - centerPx.x)**2 + (testPx.y - centerPx.y)**2);
            
            const bubble = ACOUSTIC.detectionBubble;
            
            // Dessiner la zone de d√©tection
            ctxMap.beginPath();
            const firstPx = {
                x: centerPx.x + bubble[0].x * pixelsPerMeter,
                y: centerPx.y - bubble[0].y * pixelsPerMeter
            };
            ctxMap.moveTo(firstPx.x, firstPx.y);
            
            for (let i = 1; i < bubble.length; i++) {
                const px = centerPx.x + bubble[i].x * pixelsPerMeter;
                const py = centerPx.y - bubble[i].y * pixelsPerMeter;
                ctxMap.lineTo(px, py);
            }
            ctxMap.closePath();
            
            // Remplissage gradient
            const maxRange = Math.max(...bubble.map(p => p.range));
            const gradient = ctxMap.createRadialGradient(
                centerPx.x, centerPx.y, 0,
                centerPx.x, centerPx.y, maxRange * pixelsPerMeter
            );
            gradient.addColorStop(0, 'rgba(138, 43, 226, 0.12)');
            gradient.addColorStop(0.7, 'rgba(138, 43, 226, 0.06)');
            gradient.addColorStop(1, 'rgba(138, 43, 226, 0.02)');
            
            ctxMap.fillStyle = gradient;
            ctxMap.fill();
            
            // Contour
            ctxMap.strokeStyle = 'rgba(138, 43, 226, 0.4)';
            ctxMap.lineWidth = 2;
            ctxMap.setLineDash([5, 5]);
            ctxMap.stroke();
            ctxMap.setLineDash([]);
        }
        
        // Traces
        [{ trace: sim.traceReal, color: 'rgba(255,59,59,0.6)' }, { trace: sim.traceEst, color: 'rgba(0,255,136,0.6)' }].forEach(({ trace, color }) => {
            if (trace.length < 2) return;
            for (let i = 1; i < trace.length; i++) {
                const alpha = Math.max(0.1, 1 - (sim.time - trace[i].t)/TRACE_DURATION);
                const ll0 = metersToLatLon(trace[i-1].x, trace[i-1].y);
                const ll1 = metersToLatLon(trace[i].x, trace[i].y);
                const p0 = toPixel(ll0.lat, ll0.lon), p1 = toPixel(ll1.lat, ll1.lon);
                ctxMap.strokeStyle = color.replace(/[\d.]+\)$/, (alpha*0.8).toFixed(2)+')');
                ctxMap.lineWidth = 3;
                ctxMap.beginPath(); ctxMap.moveTo(p0.x, p0.y); ctxMap.lineTo(p1.x, p1.y); ctxMap.stroke();
            }
        });
        
        // Position r√©elle
        if (!sim.fireControl.droneDestroyed) {
            const droneLL = metersToLatLon(sim.drone.x, sim.drone.y);
            const dp = toPixel(droneLL.lat, droneLL.lon);
            ctxMap.fillStyle = 'rgba(255,59,59,0.3)';
            ctxMap.beginPath(); ctxMap.arc(dp.x, dp.y, 10, 0, 2*Math.PI); ctxMap.fill();
            ctxMap.fillStyle = '#ff3b3b';
            ctxMap.beginPath(); ctxMap.arc(dp.x, dp.y, 5, 0, 2*Math.PI); ctxMap.fill();
        }
        
        // Position estim√©e
        const e = sim.est;
        const estX = e.distance*Math.cos(e.azimuth)*Math.cos(e.elevation);
        const estY = e.distance*Math.sin(e.azimuth)*Math.cos(e.elevation);
        const estLL = metersToLatLon(estX, estY);
        const ep = toPixel(estLL.lat, estLL.lon);
        
        // =====================================================
        // ELLIPSE DE CONFIANCE (coh√©rence g√©om√©trique)
        // =====================================================
        if (COHERENCE.enabled && COHERENCE.confidenceEllipse) {
            const ell = COHERENCE.confidenceEllipse;
            const ellCenter = metersToLatLon(ell.centerX, ell.centerY);
            const centerPx = toPixel(ellCenter.lat, ellCenter.lon);
            
            // Conversion des rayons en pixels (approximation locale)
            const testPoint = metersToLatLon(ell.centerX + 1, ell.centerY);
            const testPx = toPixel(testPoint.lat, testPoint.lon);
            const pixelsPerMeter = Math.sqrt((testPx.x - centerPx.x)**2 + (testPx.y - centerPx.y)**2);
            
            const radiusXpx = Math.max(5, Math.min(100, ell.radiusX * pixelsPerMeter));
            const radiusYpx = Math.max(5, Math.min(100, ell.radiusY * pixelsPerMeter));
            
            ctxMap.save();
            ctxMap.translate(centerPx.x, centerPx.y);
            ctxMap.rotate(-ell.angle); // N√©gatif car Y invers√©
            
            // Couleur selon coh√©rence
            const coherence = e.coherence || 100;
            let ellColor;
            if (coherence > 70) {
                ellColor = 'rgba(0, 255, 136, 0.3)';
            } else if (coherence > 40) {
                ellColor = 'rgba(255, 215, 0, 0.3)';
            } else {
                ellColor = 'rgba(255, 59, 59, 0.4)';
            }
            
            ctxMap.fillStyle = ellColor;
            ctxMap.beginPath();
            ctxMap.ellipse(0, 0, radiusXpx, radiusYpx, 0, 0, 2 * Math.PI);
            ctxMap.fill();
            
            // Contour
            ctxMap.strokeStyle = ellColor.replace('0.3', '0.8').replace('0.4', '0.9');
            ctxMap.lineWidth = 1;
            ctxMap.stroke();
            
            ctxMap.restore();
        }
        
        // =====================================================
        // FL√àCHE DE VENT sur la carte
        // =====================================================
        if (WIND_CONFIG.enabled) {
            const wind = getWindVector(50); // Vent √† 50m
            const centerPx = toPixel(rxLat, rxLon);
            
            // Position de la fl√®che (coin sup√©rieur droit de la carte)
            const arrowX = w - 40;
            const arrowY = 40;
            
            // Taille proportionnelle √† la vitesse
            const arrowLen = 15 + wind.speedKmh * 0.3;
            const dirRad = WIND_CONFIG.currentDirection * Math.PI / 180;
            
            // Fond
            ctxMap.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctxMap.beginPath();
            ctxMap.arc(arrowX, arrowY, 25, 0, 2 * Math.PI);
            ctxMap.fill();
            
            // Fl√®che
            const tipX = arrowX + Math.sin(dirRad) * arrowLen;
            const tipY = arrowY - Math.cos(dirRad) * arrowLen;
            const tailX = arrowX - Math.sin(dirRad) * arrowLen * 0.5;
            const tailY = arrowY + Math.cos(dirRad) * arrowLen * 0.5;
            
            ctxMap.strokeStyle = WIND_CONFIG.isGusting ? '#ff3b3b' : '#00bfff';
            ctxMap.lineWidth = 2;
            ctxMap.beginPath();
            ctxMap.moveTo(tailX, tailY);
            ctxMap.lineTo(tipX, tipY);
            ctxMap.stroke();
            
            // Pointe
            const headLen = 6;
            const headAngle = Math.PI / 6;
            ctxMap.beginPath();
            ctxMap.moveTo(tipX, tipY);
            ctxMap.lineTo(
                tipX - headLen * Math.sin(dirRad - headAngle),
                tipY + headLen * Math.cos(dirRad - headAngle)
            );
            ctxMap.moveTo(tipX, tipY);
            ctxMap.lineTo(
                tipX - headLen * Math.sin(dirRad + headAngle),
                tipY + headLen * Math.cos(dirRad + headAngle)
            );
            ctxMap.stroke();
            
            // Texte vitesse
            ctxMap.fillStyle = '#00bfff';
            ctxMap.font = '8px Courier New';
            ctxMap.textAlign = 'center';
            ctxMap.fillText(wind.speedKmh.toFixed(0) + ' km/h', arrowX, arrowY + 32);
        }
        
        ctxMap.fillStyle = 'rgba(0,255,136,0.3)';
        ctxMap.beginPath(); ctxMap.arc(ep.x, ep.y, 10, 0, 2*Math.PI); ctxMap.fill();
        ctxMap.fillStyle = '#00ff88';
        ctxMap.beginPath(); ctxMap.arc(ep.x, ep.y, 5, 0, 2*Math.PI); ctxMap.fill();
    }
    
    function drawSide() {
        const w = canvasSide.width, h = canvasSide.height;
        const cx = w/2, cy = h*0.85;
        const scale = Math.min(w, h*0.75) / (BUBBLE_RADIUS*2.4);
        
        ctxSide.fillStyle = '#0a0e14';
        ctxSide.fillRect(0, 0, w, h);
        
        // Sol
        ctxSide.strokeStyle = 'rgba(0,212,255,0.3)';
        ctxSide.lineWidth = 1;
        ctxSide.beginPath(); ctxSide.moveTo(0, cy); ctxSide.lineTo(w, cy); ctxSide.stroke();
        
        // Handover zone
        ctxSide.strokeStyle = 'rgba(255,0,255,0.3)';
        ctxSide.setLineDash([3,3]);
        ctxSide.beginPath();
        ctxSide.moveTo(cx - HANDOVER_DISTANCE*scale, cy);
        ctxSide.lineTo(cx - HANDOVER_DISTANCE*scale, cy - 80*scale);
        ctxSide.moveTo(cx + HANDOVER_DISTANCE*scale, cy);
        ctxSide.lineTo(cx + HANDOVER_DISTANCE*scale, cy - 80*scale);
        ctxSide.stroke();
        ctxSide.setLineDash([]);
        
        // Capteur
        ctxSide.fillStyle = '#8b5cf6';
        ctxSide.beginPath(); ctxSide.arc(cx, cy, 4, 0, 2*Math.PI); ctxSide.fill();
        
        // Traces
        [{ trace: sim.traceReal, color: '#ff3b3b' }, { trace: sim.traceEst, color: '#00ff88' }].forEach(({ trace, color }) => {
            if (trace.length < 2) return;
            for (let i = 1; i < trace.length; i++) {
                const alpha = Math.max(0.1, 1 - (sim.time - trace[i].t)/TRACE_DURATION);
                ctxSide.strokeStyle = hexToRgba(color, alpha*0.6);
                ctxSide.lineWidth = 2;
                ctxSide.beginPath();
                ctxSide.moveTo(cx + trace[i-1].x*scale, cy - trace[i-1].z*scale);
                ctxSide.lineTo(cx + trace[i].x*scale, cy - trace[i].z*scale);
                ctxSide.stroke();
            }
        });
        
        // Positions
        if (!sim.fireControl.droneDestroyed) {
            ctxSide.fillStyle = '#ff3b3b';
            ctxSide.beginPath(); ctxSide.arc(cx + sim.drone.x*scale, cy - sim.drone.z*scale, 4, 0, 2*Math.PI); ctxSide.fill();
        }
        
        const e = sim.est;
        ctxSide.fillStyle = '#00ff88';
        ctxSide.beginPath(); ctxSide.arc(cx + e.distance*Math.cos(e.azimuth)*scale, cy - e.distance*Math.sin(e.elevation)*scale, 4, 0, 2*Math.PI); ctxSide.fill();
    }
    
    function drawCamera() {
        const w = canvasCamera.width, h = canvasCamera.height;
        const cx = w/2, cy = h/2;
        const fc = sim.fireControl;
        const e = sim.est;
        
        // =====================================================
        // CAM√âRA TOUJOURS ACTIVE - Suit le point VERT (estim√©)
        // =====================================================
        
        // Fond - plus sombre hors engagement
        const inEngagement = fc.mode === 'camera';
        ctxCamera.fillStyle = inEngagement ? '#0a0a14' : '#08080c';
        ctxCamera.fillRect(0, 0, w, h);
        
        const panel = document.getElementById('cameraPanel');
        const label = panel.querySelector('.view-label');
        
        // Kill confirmed
        if (fc.droneDestroyed) {
            label.textContent = 'CAM√âRA - KILL CONFIRMED';
            panel.classList.add('camera-active');
            ctxCamera.fillStyle = '#00ff88';
            ctxCamera.font = 'bold 16px Arial Black';
            ctxCamera.textAlign = 'center';
            ctxCamera.fillText('TARGET DOWN', cx, cy - 10);
            ctxCamera.font = '10px Courier New';
            ctxCamera.fillText(`Respawn: ${(RESPAWN_DELAY - fc.respawnTimer).toFixed(1)}s`, cx, cy + 15);
            return;
        }
        
        // Label selon mode
        if (inEngagement) {
            panel.classList.add('camera-active');
            label.textContent = fc.lockOn ? 'CAM√âRA - LOCK ON' : (fc.visualContact ? 'CAM√âRA - TRACKING' : 'CAM√âRA - ACQUISITION');
        } else {
            panel.classList.remove('camera-active');
            label.textContent = `CAM√âRA - VEILLE (${e.distance.toFixed(0)}m)`;
        }
        
        // =====================================================
        // LA CAM√âRA SUIT TOUJOURS LE POINT VERT (estim√©)
        // =====================================================
        const estAz = e.azimuth;
        const estEl = e.elevation;
        
        // En mode veille: la cam√©ra suit passivement l'estim√©
        // En mode engagement: updateFireControl g√®re le tracking actif
        if (!inEngagement) {
            // Suivi passif doux vers l'estim√©
            const smoothing = 0.08;
            let azDiff = estAz - fc.cameraAz;
            if (azDiff > Math.PI) azDiff -= 2*Math.PI;
            if (azDiff < -Math.PI) azDiff += 2*Math.PI;
            
            fc.cameraAz += azDiff * smoothing;
            fc.cameraEl += (estEl - fc.cameraEl) * smoothing;
        }
        
        // =====================================================
        // GRILLE DE FOND
        // =====================================================
        ctxCamera.strokeStyle = inEngagement ? 'rgba(0,212,255,0.1)' : 'rgba(0,212,255,0.05)';
        ctxCamera.lineWidth = 1;
        for (let i = 0; i < w; i += 25) { 
            ctxCamera.beginPath(); 
            ctxCamera.moveTo(i, 0); 
            ctxCamera.lineTo(i, h); 
            ctxCamera.stroke(); 
        }
        for (let i = 0; i < h; i += 25) { 
            ctxCamera.beginPath(); 
            ctxCamera.moveTo(0, i); 
            ctxCamera.lineTo(w, i); 
            ctxCamera.stroke(); 
        }
        
        // =====================================================
        // FOV SCALE - Zoom bas√© sur distance d'engagement
        // √Ä 35m, le drone doit avoir une taille significative
        // =====================================================
        const engagementDist = HANDOVER_DISTANCE; // 35m
        const baseFOV = Math.PI/6; // 30¬∞ de FOV
        const fovScale = Math.min(w, h) / baseFOV;
        
        // =====================================================
        // DRONE R√âEL (ROUGE) - Position dans le FOV
        // =====================================================
        const realDist = magnitude(sim.drone);
        const realAz = Math.atan2(sim.drone.y, sim.drone.x);
        const realEl = Math.asin(sim.drone.z / Math.max(realDist, EPSILON_DISTANCE));
        
        let azOffReal = realAz - fc.cameraAz;
        if (azOffReal > Math.PI) azOffReal -= 2*Math.PI;
        if (azOffReal < -Math.PI) azOffReal += 2*Math.PI;
        const elOffReal = realEl - fc.cameraEl;
        
        const droneScreenX = cx + azOffReal * fovScale;
        const droneScreenY = cy - elOffReal * fovScale;
        
        // Taille du drone selon distance (plus proche = plus grand)
        // √Ä 35m ‚Üí taille ~20px, √† 150m ‚Üí taille ~5px
        const sizeReal = Math.max(5, Math.min(30, engagementDist / realDist * 15));
        
        // V√©rifier si dans le FOV √©largi (¬±45¬∞) pour affichage hors champ
        const inFOV = Math.abs(azOffReal) < baseFOV && Math.abs(elOffReal) < baseFOV;
        const inExtendedFOV = Math.abs(azOffReal) < Math.PI/3 && Math.abs(elOffReal) < Math.PI/3;
        
        if (inFOV) {
            // Drone dans le champ - affichage complet
            ctxCamera.strokeStyle = inEngagement ? (fc.lockOn ? '#ff00ff' : '#ff3b3b') : '#ff3b3b88';
            ctxCamera.lineWidth = inEngagement ? 2 : 1;
            
            // Croix du drone
            ctxCamera.beginPath();
            ctxCamera.moveTo(droneScreenX - sizeReal, droneScreenY);
            ctxCamera.lineTo(droneScreenX + sizeReal, droneScreenY);
            ctxCamera.moveTo(droneScreenX, droneScreenY - sizeReal/2);
            ctxCamera.lineTo(droneScreenX, droneScreenY + sizeReal/2);
            ctxCamera.stroke();
            
            // Cadre de tracking
            ctxCamera.strokeStyle = inEngagement ? (fc.lockOn ? '#ff00ff' : '#ffff00') : '#ffff0066';
            ctxCamera.lineWidth = fc.lockOn ? 2 : 1;
            ctxCamera.strokeRect(
                droneScreenX - sizeReal - 4, 
                droneScreenY - sizeReal - 4, 
                (sizeReal + 4) * 2, 
                (sizeReal + 4) * 2
            );
            
            // Distance
            ctxCamera.fillStyle = inEngagement ? '#00d4ff' : '#00d4ff88';
            ctxCamera.font = '9px Courier New';
            ctxCamera.textAlign = 'center';
            ctxCamera.fillText(`${realDist.toFixed(0)}m`, droneScreenX, droneScreenY + sizeReal + 14);
            
        } else if (inExtendedFOV) {
            // Drone hors champ mais proche - indicateur de direction
            const edgeX = cx + Math.sign(azOffReal) * (w/2 - 15);
            const edgeY = Math.max(15, Math.min(h - 15, cy - elOffReal * fovScale));
            
            ctxCamera.fillStyle = '#ff3b3b66';
            ctxCamera.beginPath();
            if (azOffReal > 0) {
                // Fl√®che vers la droite
                ctxCamera.moveTo(edgeX, edgeY);
                ctxCamera.lineTo(edgeX - 10, edgeY - 6);
                ctxCamera.lineTo(edgeX - 10, edgeY + 6);
            } else {
                // Fl√®che vers la gauche
                ctxCamera.moveTo(edgeX, edgeY);
                ctxCamera.lineTo(edgeX + 10, edgeY - 6);
                ctxCamera.lineTo(edgeX + 10, edgeY + 6);
            }
            ctxCamera.fill();
            
            ctxCamera.fillStyle = '#ff3b3b88';
            ctxCamera.font = '8px Courier New';
            ctxCamera.textAlign = azOffReal > 0 ? 'right' : 'left';
            ctxCamera.fillText(`${realDist.toFixed(0)}m`, edgeX + (azOffReal > 0 ? -12 : 12), edgeY + 3);
        }
        
        // =====================================================
        // POINT VERT (ESTIM√â) - Petite croix verte
        // =====================================================
        let azOffEst = estAz - fc.cameraAz;
        if (azOffEst > Math.PI) azOffEst -= 2*Math.PI;
        if (azOffEst < -Math.PI) azOffEst += 2*Math.PI;
        const elOffEst = estEl - fc.cameraEl;
        
        const estScreenX = cx + azOffEst * fovScale;
        const estScreenY = cy - elOffEst * fovScale;
        
        if (Math.abs(azOffEst) < baseFOV && Math.abs(elOffEst) < baseFOV) {
            ctxCamera.strokeStyle = '#00ff8888';
            ctxCamera.lineWidth = 1;
            ctxCamera.beginPath();
            ctxCamera.moveTo(estScreenX - 6, estScreenY);
            ctxCamera.lineTo(estScreenX + 6, estScreenY);
            ctxCamera.moveTo(estScreenX, estScreenY - 6);
            ctxCamera.lineTo(estScreenX, estScreenY + 6);
            ctxCamera.stroke();
            
            // Petit cercle
            ctxCamera.beginPath();
            ctxCamera.arc(estScreenX, estScreenY, 3, 0, 2*Math.PI);
            ctxCamera.stroke();
        }
        
        // =====================================================
        // R√âTICULE CENTRAL
        // =====================================================
        ctxCamera.strokeStyle = inEngagement ? 'rgba(255,0,255,0.4)' : 'rgba(0,212,255,0.2)';
        ctxCamera.lineWidth = 1;
        
        // Croix centrale fine
        ctxCamera.beginPath();
        ctxCamera.moveTo(cx - 20, cy);
        ctxCamera.lineTo(cx - 5, cy);
        ctxCamera.moveTo(cx + 5, cy);
        ctxCamera.lineTo(cx + 20, cy);
        ctxCamera.moveTo(cx, cy - 20);
        ctxCamera.lineTo(cx, cy - 5);
        ctxCamera.moveTo(cx, cy + 5);
        ctxCamera.lineTo(cx, cy + 20);
        ctxCamera.stroke();
        
        // Cercle de tol√©rance
        ctxCamera.beginPath();
        ctxCamera.arc(cx, cy, 25, 0, 2*Math.PI);
        ctxCamera.stroke();
        
        // =====================================================
        // HUD - Informations
        // =====================================================
        ctxCamera.fillStyle = inEngagement ? '#00d4ff' : '#00d4ff88';
        ctxCamera.font = '8px Courier New';
        ctxCamera.textAlign = 'left';
        ctxCamera.fillText(`AZ: ${(fc.cameraAz * 180/Math.PI).toFixed(1)}¬∞`, 4, 12);
        ctxCamera.fillText(`EL: ${(fc.cameraEl * 180/Math.PI).toFixed(1)}¬∞`, 4, 22);
        
        ctxCamera.textAlign = 'right';
        ctxCamera.fillText(`R√âEL: ${realDist.toFixed(0)}m`, w-4, 12);
        ctxCamera.fillText(`EST: ${e.distance.toFixed(0)}m`, w-4, 22);
        
        // Indicateur engagement
        if (!inEngagement) {
            ctxCamera.fillStyle = '#8b949e';
            ctxCamera.font = '9px Courier New';
            ctxCamera.textAlign = 'center';
            ctxCamera.fillText(`HANDOVER @ ${HANDOVER_DISTANCE}m`, cx, h - 8);
            
            // Barre de progression vers engagement
            const progress = Math.max(0, Math.min(1, (150 - e.distance) / (150 - HANDOVER_DISTANCE)));
            ctxCamera.fillStyle = '#1a1a24';
            ctxCamera.fillRect(w/4, h - 22, w/2, 4);
            ctxCamera.fillStyle = progress > 0.8 ? '#ff3b3b' : '#00d4ff44';
            ctxCamera.fillRect(w/4, h - 22, w/2 * progress, 4);
        }
    }
    
    function drawReticle() {
        const w = canvasReticle.width, h = canvasReticle.height;
        const cx = w/2, cy = h/2;
        const fc = sim.fireControl;
        
        ctxReticle.fillStyle = '#050508';
        ctxReticle.fillRect(0, 0, w, h);
        
        const panel = document.getElementById('reticlePanel');
        const label = panel.querySelector('.view-label');
        
        if (fc.droneDestroyed) {
            label.textContent = 'VISEUR - NEUTRALIS√â';
            ctxReticle.fillStyle = '#00ff88';
            ctxReticle.font = 'bold 14px Arial Black';
            ctxReticle.textAlign = 'center';
            ctxReticle.fillText('KILL', cx, cy);
            return;
        }
        
        if (fc.mode !== 'camera') {
            label.textContent = 'VISEUR - STANDBY';
            ctxReticle.fillStyle = '#1a1a24';
            ctxReticle.font = '11px Courier New';
            ctxReticle.textAlign = 'center';
            ctxReticle.fillText('KH√âOPS ACTIF', cx, cy);
            return;
        }
        
        label.textContent = fc.lockOn ? 'VISEUR - FIRE' : 'VISEUR - ACQ';
        
        const color = fc.lockOn ? '#ff00ff' : (fc.targetCentered ? '#ffff00' : '#00d4ff');
        
        ctxReticle.strokeStyle = color;
        ctxReticle.lineWidth = 1;
        [15, 30, 45].forEach(r => {
            ctxReticle.beginPath();
            ctxReticle.arc(cx, cy, r, 0, 2*Math.PI);
            ctxReticle.stroke();
        });
        
        ctxReticle.lineWidth = 2;
        ctxReticle.beginPath();
        ctxReticle.moveTo(cx - 60, cy); ctxReticle.lineTo(cx - 20, cy);
        ctxReticle.moveTo(cx + 20, cy); ctxReticle.lineTo(cx + 60, cy);
        ctxReticle.moveTo(cx, cy - 60); ctxReticle.lineTo(cx, cy - 20);
        ctxReticle.moveTo(cx, cy + 20); ctxReticle.lineTo(cx, cy + 60);
        ctxReticle.stroke();
        
        if (fc.lockOn) {
            ctxReticle.fillStyle = '#ff00ff';
            ctxReticle.beginPath();
            ctxReticle.arc(cx, cy, 4, 0, 2*Math.PI);
            ctxReticle.fill();
        }
        
        ctxReticle.fillStyle = color;
        ctxReticle.font = '8px Courier New';
        ctxReticle.textAlign = 'left';
        ctxReticle.fillText(`DST: ${sim.est.distance.toFixed(0)}m`, 4, 12);
        ctxReticle.textAlign = 'right';
        ctxReticle.fillText(`TIRS: ${fc.shotsFired}`, w-4, 12);
        
        ctxReticle.textAlign = 'center';
        ctxReticle.font = 'bold 9px Arial Black';
        ctxReticle.fillText(fc.lockOn ? 'üî• FIRE' : 'TRACKING', cx, h - 8);
    }
    
    // ============================================================
    // UI
    // ============================================================
    function updateUI() {
        const d = sim.drone, e = sim.est, fc = sim.fireControl;
        
        const realDist = magnitude(d);
        const toRx = normalize({ x: -d.x, y: -d.y, z: -d.z });
        const realVr = dot({ x: d.vx, y: d.vy, z: d.vz }, toRx);
        
        const distErr = Math.abs(realDist - e.distance);
        const distErrPct = realDist > 0 ? distErr / realDist * 100 : 0;
        
        const estX = e.distance * Math.cos(e.azimuth) * Math.cos(e.elevation);
        const estY = e.distance * Math.sin(e.azimuth) * Math.cos(e.elevation);
        const estZ = e.distance * Math.sin(e.elevation);
        const estGPS = metersToLatLon(estX, estY);
        
        document.getElementById('simTime').textContent = sim.time.toFixed(2);
        
        document.getElementById('fireLat').textContent = estGPS.lat.toFixed(6);
        document.getElementById('fireLon').textContent = estGPS.lon.toFixed(6);
        document.getElementById('fireAlt').textContent = estZ.toFixed(1);
        document.getElementById('fireDist').textContent = e.distance.toFixed(1);
        
        document.getElementById('realDistance').textContent = realDist.toFixed(1);
        document.getElementById('estDistance').textContent = e.distance.toFixed(1);
        document.getElementById('distanceError').textContent = distErr.toFixed(1);
        document.getElementById('distanceErrorPct').textContent = distErrPct.toFixed(1);
        
        // Erreur Position 3D (distance euclidienne entre position estim√©e et r√©elle)
        const posErr3D = Math.sqrt((e.x - d.x)**2 + (e.y - d.y)**2 + (e.z - d.z)**2);
        document.getElementById('posError3D').textContent = posErr3D.toFixed(2);
        
        // Doppler UI
        const vRadEl = document.getElementById('vRadialValue');
        vRadEl.innerHTML = `<span style="color: ${e.dopplerIntegrating ? 'var(--accent-green)' : 'var(--accent-red)'}">${e.radialVelocity.toFixed(2)}</span><span class="unit">m/s</span>`;
        
        document.getElementById('integrationStatus').innerHTML = e.dopplerIntegrating ? 
            '<span style="color: var(--accent-green)">ACTIVE</span>' : 
            '<span style="color: var(--accent-red)">PAUSE</span>';
        
        document.getElementById('soundSpeedDisplay').textContent = SPEED_OF_SOUND.toFixed(1);
        
        document.getElementById('dopplerLabel').textContent = e.radialVelocity.toFixed(1) + ' m/s';
        
        // Barre Doppler
        const dopplerFill = document.getElementById('dopplerFill');
        const maxVr = 20;
        const normalizedVr = (e.radialVelocity + maxVr) / (2 * maxVr); // 0-1
        const fillWidth = Math.max(0, Math.min(100, normalizedVr * 100));
        dopplerFill.style.width = fillWidth + '%';
        dopplerFill.style.background = e.radialVelocity > 0 ? 'var(--accent-green)' : 'var(--accent-cyan)';
        dopplerFill.style.marginLeft = e.radialVelocity > 0 ? '50%' : (fillWidth) + '%';
        dopplerFill.style.width = Math.abs(e.radialVelocity) / maxVr * 50 + '%';
        
        // Handover
        document.getElementById('hoverKheops').classList.toggle('active', fc.mode === 'kheops');
        document.getElementById('hoverCamera').classList.toggle('active', fc.mode === 'camera');
        
        // Stats
        document.getElementById('killCount').textContent = sim.stats.totalKills;
        document.getElementById('totalShots').textContent = sim.stats.totalShots;
        const acc = sim.stats.totalShots > 0 ? (sim.stats.totalKills / sim.stats.totalShots * 100).toFixed(0) : '--';
        document.getElementById('accuracy').textContent = acc + '%';
        
        // Fire assessment
        const fa = document.getElementById('fireAssessment');
        
        if (fc.droneDestroyed) {
            fa.className = 'fire-assessment fire-go';
            fa.innerHTML = `<div class="fire-status">NEUTRALIS√â</div><div class="fire-details">Respawn: ${(RESPAWN_DELAY - fc.respawnTimer).toFixed(1)}s</div>`;
        } else if (fc.mode === 'camera' && fc.lockOn) {
            fa.className = 'fire-assessment fire-engaged';
            fa.innerHTML = `<div class="fire-status">üî• ENGAGED</div><div class="fire-details">Tir auto actif</div>`;
        } else if (fc.mode === 'camera') {
            fa.className = 'fire-assessment fire-no-go';
            fa.innerHTML = `<div class="fire-status">TRACKING</div><div class="fire-details">Acquisition...</div>`;
        } else {
            fa.className = 'fire-assessment fire-no-go';
            fa.innerHTML = `<div class="fire-status">KH√âOPS</div><div class="fire-details">Handover < ${HANDOVER_DISTANCE}m</div>`;
        }
        
        // Status
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        if (fc.droneDestroyed) {
            statusDot.style.background = '#00ff88';
            statusText.textContent = 'KILL';
        } else if (fc.mode === 'camera') {
            statusDot.style.background = '#ff00ff';
            statusText.textContent = sim.timeScale < 1 ? 'SLOWMO' : 'CAMERA';
        } else {
            statusDot.style.background = '#00ff88';
            statusText.textContent = 'KH√âOPS';
        }
        
        // ISO 9613-1 Diagnostics
        updateISODisplay();
    }
    
    /**
     * Mise √† jour de l'affichage des param√®tres ISO 9613-1
     */
    function updateISODisplay() {
        const details = calculateSpeedOfSoundDetailed(TEMPERATURE, HUMIDITY, PRESSURE, CO2_FRACTION);
        
        // Pression de vapeur saturante
        document.getElementById('isoPsat').textContent = details.saturationPressure_Pa.toFixed(1);
        
        // Facteur d'augmentation
        document.getElementById('isoEnhancement').textContent = details.enhancementFactor.toFixed(6);
        
        // Fraction molaire H2O (notation scientifique si petit)
        const xwDisplay = details.molarFractionH2O < 0.001 
            ? details.molarFractionH2O.toExponential(3) 
            : details.molarFractionH2O.toFixed(5);
        document.getElementById('isoXw').textContent = xwDisplay;
        
        // Fraction molaire CO2
        document.getElementById('isoXc').textContent = (details.molarFractionCO2 * 1e6).toFixed(0) + ' ppm';
        
        // Masse molaire (convertir kg/mol vers g/mol)
        document.getElementById('isoM').textContent = (details.molarMass_kgmol * 1000).toFixed(4);
        
        // Gamma
        document.getElementById('isoGamma').textContent = details.gammaRatio.toFixed(5);
        
        // Comparaison ISO vs Cramer
        const cISO = details.speedOfSound_ISO.toFixed(3);
        const cCramer = details.speedOfSound_Cramer.toFixed(3);
        const delta = details.deviation_ms.toFixed(4);
        document.getElementById('isoComparison').innerHTML = 
            `${cISO} vs ${cCramer} <span style="color: var(--accent-yellow);">(Œî${delta})</span>`;
        
        // Mise √† jour affichage VENT
        updateWindDisplay();
        
        // Mise √† jour affichage COH√âRENCE
        updateCoherenceDisplay();
        
        // Mise √† jour affichage ACOUSTIQUE
        updateAcousticDisplay();
    }
    
    /**
     * Mise √† jour affichage du panneau VENT
     */
    function updateWindDisplay() {
        const cfg = WIND_CONFIG;
        
        document.getElementById('windSpeed').textContent = cfg.currentSpeed.toFixed(1);
        document.getElementById('windDirection').textContent = cfg.currentDirection.toFixed(0);
        
        // Status
        const statusEl = document.getElementById('windStatus');
        if (!cfg.enabled) {
            statusEl.innerHTML = '<span style="color: var(--text-secondary);">D√âSACTIV√â</span>';
        } else if (cfg.isGusting) {
            statusEl.innerHTML = '<span style="color: var(--accent-red); animation: blink 0.3s infinite;">üå¨Ô∏è RAFALE</span>';
        } else {
            statusEl.innerHTML = '<span style="color: var(--accent-green);">NORMAL</span>';
        }
        
        // Rose des vents
        drawWindRose();
    }
    
    /**
     * Dessiner la mini rose des vents
     */
    function drawWindRose() {
        const canvas = document.getElementById('windRose');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const w = canvas.width, h = canvas.height;
        const cx = w/2, cy = h/2, r = Math.min(w, h) / 2 - 4;
        
        ctx.clearRect(0, 0, w, h);
        
        // Cercle de fond
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(0, 191, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Points cardinaux
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = '8px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('N', cx, cy - r + 6);
        ctx.fillText('S', cx, cy + r - 6);
        ctx.fillText('E', cx + r - 6, cy);
        ctx.fillText('W', cx - r + 6, cy);
        
        // Fl√®che de vent (direction d'o√π il vient)
        const dirRad = WIND_CONFIG.currentDirection * Math.PI / 180;
        const arrowLen = r * 0.7 * Math.min(1, WIND_CONFIG.currentSpeed / 50);
        
        // Pointe de la fl√®che (d'o√π vient le vent)
        const tipX = cx + Math.sin(dirRad) * arrowLen;
        const tipY = cy - Math.cos(dirRad) * arrowLen;
        
        // Queue
        const tailX = cx - Math.sin(dirRad) * arrowLen * 0.3;
        const tailY = cy + Math.cos(dirRad) * arrowLen * 0.3;
        
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(tipX, tipY);
        ctx.strokeStyle = WIND_CONFIG.isGusting ? '#ff3b3b' : '#00bfff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Pointe
        const headLen = 6;
        const headAngle = Math.PI / 6;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(
            tipX - headLen * Math.sin(dirRad - headAngle),
            tipY + headLen * Math.cos(dirRad - headAngle)
        );
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(
            tipX - headLen * Math.sin(dirRad + headAngle),
            tipY + headLen * Math.cos(dirRad + headAngle)
        );
        ctx.stroke();
    }
    
    /**
     * Mise √† jour affichage du panneau COH√âRENCE
     */
    function updateCoherenceDisplay() {
        const e = sim.est;
        const coh = COHERENCE;
        
        // Indice de coh√©rence
        const indexEl = document.getElementById('coherenceIndex');
        const coherence = e.coherence || 100;
        indexEl.textContent = coherence.toFixed(0);
        
        // Couleur selon niveau
        if (coherence > 70) {
            indexEl.style.color = 'var(--accent-green)';
        } else if (coherence > 40) {
            indexEl.style.color = 'var(--accent-yellow)';
        } else {
            indexEl.style.color = 'var(--accent-red)';
        }
        
        // Dispersion
        document.getElementById('coherenceDispersion').textContent = (e.dispersion || 0).toFixed(2);
        
        // Nombre de solutions
        document.getElementById('coherenceSolutions').textContent = coh.solutions ? coh.solutions.length : '--';
        
        // Barre de coh√©rence
        const bar = document.getElementById('coherenceBar');
        bar.style.width = coherence + '%';
        
        // Alerte rafale
        const alertEl = document.getElementById('gustAlert');
        if (WIND_CONFIG.isGusting || coherence < 30) {
            alertEl.style.display = 'block';
        } else {
            alertEl.style.display = 'none';
        }
        
        // Alerte zone z√©nithale
        const zenithAlert = document.getElementById('zenithAlert');
        if (e.isZenith) {
            zenithAlert.style.display = 'block';
        } else {
            zenithAlert.style.display = 'none';
        }
    }
    
    /**
     * Contr√¥les UI pour le vent
     */
    function toggleWind(enabled) {
        WIND_CONFIG.enabled = enabled;
    }
    
    function updateWindBase(v) {
        WIND_CONFIG.baseSpeed = parseFloat(v);
        WIND_CONFIG.currentSpeed = parseFloat(v);
        document.getElementById('windBaseDisplay').textContent = v + ' km/h';
    }
    
    function updateWindDirection(v) {
        WIND_CONFIG.baseDirection = parseFloat(v);
        WIND_CONFIG.currentDirection = parseFloat(v);
        WIND_CONFIG.targetDirection = parseFloat(v);
        document.getElementById('windDirDisplay').textContent = v + '¬∞';
    }
    
    /**
     * Contr√¥les UI pour la coh√©rence
     */
    function toggleCoherence(enabled) {
        COHERENCE.enabled = enabled;
    }
    
    /**
     * Mise √† jour affichage du panneau ACOUSTIQUE
     */
    function updateAcousticDisplay() {
        // Calculer SNR actuel
        const snrInfo = calculateSNR(sim.drone);
        
        // Calculer la bulle de d√©tection
        calculateDetectionBubble();
        
        // Afficher SNR
        const snrEl = document.getElementById('snrValue');
        snrEl.textContent = snrInfo.SNR.toFixed(1);
        
        // Couleur selon SNR
        if (snrInfo.SNR >= 15) {
            snrEl.style.color = 'var(--accent-green)';
        } else if (snrInfo.SNR >= ACOUSTIC.detectionThreshold) {
            snrEl.style.color = 'var(--accent-yellow)';
        } else {
            snrEl.style.color = 'var(--accent-red)';
        }
        
        // Niveau re√ßu et bruit de fond
        document.getElementById('receivedLevel').textContent = snrInfo.receivedLevel.toFixed(1);
        document.getElementById('backgroundNoise').textContent = ACOUSTIC.backgroundNoise.toFixed(0);
        
        // Port√©e max (moyenne de la bulle)
        if (ACOUSTIC.detectionBubble.length > 0) {
            const maxRange = Math.max(...ACOUSTIC.detectionBubble.map(p => p.range));
            document.getElementById('maxRange').textContent = maxRange.toFixed(0);
        }
        
        // Barre SNR (normaliser sur -10 √† +40 dB)
        const snrBar = document.getElementById('snrBar');
        const snrPct = Math.max(0, Math.min(100, (snrInfo.SNR + 10) / 50 * 100));
        snrBar.style.width = snrPct + '%';
        
        // Couleur de la barre
        if (snrInfo.SNR < ACOUSTIC.detectionThreshold) {
            snrBar.style.background = 'var(--accent-red)';
        } else if (snrInfo.SNR < 15) {
            snrBar.style.background = 'linear-gradient(90deg, var(--accent-yellow), var(--accent-orange))';
        } else {
            snrBar.style.background = 'linear-gradient(90deg, #8a2be2, var(--accent-green))';
        }
        
        // Alerte Signal Perdu
        const signalAlert = document.getElementById('signalLostAlert');
        if (sim.est.signalLost) {
            signalAlert.style.display = 'block';
        } else {
            signalAlert.style.display = 'none';
        }
    }
    
    /**
     * Mise √† jour du type de drone
     */
    function updateDroneType(type) {
        ACOUSTIC.droneType = type;
        document.getElementById('droneTypeDisplay').textContent = DRONE_TYPES[type].name;
    }
    
    /**
     * Mise √† jour du terrain (bruit de fond)
     */
    function updateTerrain(type) {
        ACOUSTIC.terrainType = type;
        ACOUSTIC.backgroundNoise = TERRAIN_TYPES[type].noise;
        document.getElementById('terrainDisplay').textContent = TERRAIN_TYPES[type].name;
    }
    
    // ============================================================
    // LOOP
    // ============================================================
    function step() {
        if (!sim.running) return;
        
        const dt = BASE_DT * sim.timeScale;
        sim.time += dt;
        
        // Mise √† jour du vent (perturbateur)
        updateWind(dt);
        
        updateDrone();
        updateEstimator();
        updateFireControl();
        updateTraces();
        updateUI();
        draw();
        
        animationId = requestAnimationFrame(step);
    }
    
    // ============================================================
    // CONTROLS
    // ============================================================
    function toggleSimulation() {
        sim.running = !sim.running;
        document.getElementById('startBtn').textContent = sim.running ? '‚è∏ PAUSE' : '‚ñ∂ START';
        if (sim.running) step();
        else if (animationId) cancelAnimationFrame(animationId);
    }
    
    function resetSimulation() {
        sim.running = false;
        if (animationId) cancelAnimationFrame(animationId);
        sim.time = 0;
        spawnDrone();
        document.getElementById('startBtn').textContent = '‚ñ∂ START';
        if (map) map.setView([rxLat, rxLon], 17);
        updateUI();
        draw();
    }
    
    function resetStats() {
        sim.stats.totalKills = 0;
        sim.stats.totalShots = 0;
        updateUI();
    }
    
    function updateHandover(v) {
        HANDOVER_DISTANCE = parseFloat(v);
        document.getElementById('handoverDisplay').textContent = v + ' m';
        // Mettre √† jour le cercle violet sur la carte
        if (handoverCircle) {
            handoverCircle.setRadius(HANDOVER_DISTANCE);
        }
    }
    
    function updateSpeed(v) {
        const newSpeed = parseFloat(v);
        const d = sim.drone;
        const curr = magnitude({ x: d.vx, y: d.vy, z: d.vz });
        // Protection EPSILON contre division par z√©ro
        const safeCurr = Math.max(curr, EPSILON_VELOCITY);
        if (curr > EPSILON_VELOCITY) {
            const f = newSpeed / safeCurr;
            d.vx *= f; d.vy *= f;
        } else {
            // Drone statique: initialiser une direction arbitraire
            const angle = Math.atan2(d.y, d.x) + Math.PI; // Vers le centre
            d.vx = newSpeed * Math.cos(angle);
            d.vy = newSpeed * Math.sin(angle);
        }
        d.speed = newSpeed;
        document.getElementById('speedDisplay').textContent = v + ' m/s';
    }
    
    function updateSpread(v) {
        SHOTGUN_SPREAD = parseFloat(v);
        document.getElementById('spreadDisplay').textContent = v + ' m';
    }
    
    function updateRespawn(v) {
        RESPAWN_DELAY = parseFloat(v);
        document.getElementById('respawnDisplay').textContent = v + ' s';
    }
    
    function updateTemperature(v) {
        TEMPERATURE = parseFloat(v);
        SPEED_OF_SOUND = calculateSpeedOfSound(TEMPERATURE, HUMIDITY);
        document.getElementById('tempDisplay').textContent = v + ' ¬∞C';
    }
    
    function updateHumidity(v) {
        HUMIDITY = parseFloat(v);
        SPEED_OF_SOUND = calculateSpeedOfSound(TEMPERATURE, HUMIDITY);
        document.getElementById('humidityDisplay').textContent = v + ' %';
    }
    
    function updatePressure(v) {
        PRESSURE = parseFloat(v);
        SPEED_OF_SOUND = calculateSpeedOfSound(TEMPERATURE, HUMIDITY);
        document.getElementById('pressureDisplay').textContent = v + ' hPa';
    }
    
    function updateCO2(v) {
        CO2_FRACTION = parseFloat(v) / 1000000; // ppm vers fraction
        SPEED_OF_SOUND = calculateSpeedOfSound(TEMPERATURE, HUMIDITY);
        document.getElementById('co2Display').textContent = v + ' ppm';
    }
    
    window.onload = init;
    </script>
</body>
</html>
